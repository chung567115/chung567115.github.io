---
title: 观察者模式
categories: 
  - 设计模式
tags:
  - Java
  - 设计模式
date: 2019-03-01 13:06:26
---

> 代码详解观察者模式

<!-- more -->
# 观察者模式
&emsp;&emsp;<kbd>观察者模式</kbd>中，当一个对象被修改时，会自动通知它的依赖对象。

- 优点： 
1. 观察者和被观察者是抽象耦合的；
2. 建立了一套触发机制。

- 缺点： 
1. 如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。
2. 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。

![UML](https://raw.githubusercontent.com/chung567115/chung567115.github.io/hexo-blog/blog-img/观察者模式.png)

```java
// 被观察者
public class Subject {
   private List<Observer> observers = new ArrayList<Observer>();
   private int state;
 
   public int getState() {
      return state;
   }
 
   public void setState(int state) {
      this.state = state;
      notifyAllObservers();
   }
 
   public void attach(Observer observer){
      observers.add(observer);      
   }
 
   public void notifyAllObservers(){
      for (Observer observer : observers) {
         observer.update();
      }
   }  
}

// 观察者抽象类
public abstract class Observer {
   protected Subject subject;
   public abstract void update();
}

// 二进制观察者实体类
public class BinaryObserver extends Observer{
   public BinaryObserver(Subject subject){
      this.subject = subject;
      this.subject.attach(this);
   }
 
   @Override
   public void update() {
      System.out.println(Integer.toBinaryString(subject.getState())); 
   }
}

// 八进制观察者实体类
public class OctalObserver extends Observer{
   public OctalObserver(Subject subject){
      this.subject = subject;
      this.subject.attach(this);
   }
 
   @Override
   public void update() {
      System.out.println(Integer.toOctalString(subject.getState())); 
   }
}

// 使用示例
public class Demo {
   public static void main(String[] args) {
      Subject subject = new Subject();
      new BinaryObserver(subject);
      new OctalObserver(subject);
       
      subject.setState(15); 
      subject.setState(10);
   }
}
```
