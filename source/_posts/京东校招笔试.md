---
title: 京东校招笔试
categories: 
  - 笔经面经
tags:
  - Java
  - 京东
  - 校招
date: 2018-04-09 21:43:39
---

> 2018年4月9日19:00–21:00，参与了京东春招在线考试，3道编程题记录如下：

<!-- more -->

# 生成回文串
**题目描述：** 
&emsp;&emsp;对于一个字符串，从前开始读和从后开始读是一样的，我们就称这个字符串是回文串。例如$ABCBA$，$AA$，$A$是回文串，而$ABCD$和$AAB$不是回文串。牛牛特别喜欢回文串，他手中有一个字符串 $s$ ，牛牛在思考能否从字符串中移除部分（0个或多个）字符使其变为回文串。并且牛牛认为空串不是回文串。
&emsp;&emsp;牛牛发现移除的方案可能有很多种，希望你帮他计算一下一共有多少种移除方案可以使 $s$ 变为回文串。*对于两种移除方案，如果移除的字符构成的序列不一样就是不同的方案。*

**输入描述** 
输入包括一个字符串$ s (1 \leq length(s) \leq 50 )$，$s$ 中只包含大写字母。

**输出描述**
对于每个测试用例，输出一个正整数表示方案数。

**样例输入1**
```text
XXY
```

**样例输出1**
```text
4
```

**样例输入2**
```text
ABA
```

**样例输出2**
```text
5
```

> 时间限制：C/C++语言 1秒；其他语言 2秒
> 内存限制：C/C++语言 32768KB；其他语言 65536KB

```java
未完成
```

# 分解整数
**题目描述：**
&emsp;&emsp; 牛牛的数学老师给了他一个整数 $N$ ，问牛牛能否将 $N$ 分解为两个整数 $X$ 和 $Y$ 相乘，并且满足 $X$ 为奇数， $Y$ 为偶数。即奇数 $X$ 和偶数 $Y$ 满足 $X * Y = N$ 。牛牛被这个问题难住了，希望你能帮他计算。

**输入描述**
输入的第一行包含一个正整数 $t (1 \leq t \leq 1000)$，表示测试样例数。接下来 $t$ 行，每行一个正整数 $N (2 \leq N \leq 2^{63})$，表示给出的 $N $，保证 $N$ 不是 2 的幂次。

**输出描述**
如果能找到这样的 $X$，$Y$ 则依次输出，以空格分割，如果有多解，输出 $Y$ 最小的那组解。否则输出 $No$。

**样例输入**
```text
2
10
5
```

**样例输出**
```text
5 2
No
```


> 时间限制：C/C++语言 3秒；其他语言 6秒
> 内存限制：C/C++语言 32768KB；其他语言 65536KB

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int t = in.nextInt();
        Long num[] = new Long[t];
        for (int i = 0; i < t; i++) {
            num[i] = in.nextLong();
            find(num[i]);
        }
    }

    static void find(Long num) {
        Long x = 1L, y = 2L;
        boolean NONE = true;
        if (num % 2 == 0) {
            for (Long k = 1L; k < num / 4; k++) {
                y = 2 * k;
                x = num / y;
                if (num % y == 0 && x % 2 == 1) {
                    NONE = false;
                    break;
                }
            }
        }
        System.out.println(NONE ? "No" : x + " " + y);
    }
}
```

# 括号匹配
**题目描述：** 
&emsp;&emsp;如果一个括号序列中的每一个左括号都有一个右括号与之完成配对，这个序列就是一个合法的括号匹配序列。例如$((()))$，$()()()$是合法的括号匹配序列。而$(((())$，$()((()$不是。牛牛得到了一系列的括号序列，他要从这个序列中任意选取两个位置进行一次交换操作（必须进行且仅一次），牛牛想知道能否通过这次操作，把这个序列变为合法括号匹配序列。例如序列$())($，对第三个位置和第四个位置进行交换，就能变成一个合法序列。

**输入描述**
输入的第一行包括测试样例数 $t (1 \leq  t \leq 1000)$，接下来的 $t$ 行，每行一个括号序列 $s (1 \leq length(s) \leq 100000)$，表示每个括号序列。

**输出描述**
如果可以通过一次交换操作变换为合法括号匹配序列，则输出 $Yes$ ，否则输出 $No$ 。

**样例输入**
```text
2
())(
)))(((
```

**样例输出**
```text
Yes
No
```


> 时间限制：C/C++语言 2秒；其他语言 4秒
> 内存限制：C/C++语言 32768KB；其他语言 65536KB

```java
//(70%)
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int t = Integer.parseInt(in.nextLine());
        String[] s = new String[t];
        for (int i = 0; i < t; i++) {
            s[i] = in.nextLine();
            judge(s[i]);
        }
    }

    static void judge(String s) {
        boolean flag = true;
        int error = 0;
        Stack stack = new Stack();
        for (int i = 0; i < s.trim().length(); i++) {
            if (s.trim().substring(i, i + 1).equals("(")) {
                stack.push("(");
            } else {
                if (error == 1) {
                    flag = false;
                    break;
                }
                if (stack.empty()) {
                    error++;
                } else {
                    stack.pop();
                }
            }
        }

        if (flag) {
            if (error == 1) {
                stack.pop();
                if (!stack.empty()) {
                    flag = false;
                }
            } else {
                if (!stack.empty()) {
                    flag = false;
                }
            }
        }
        System.out.println(flag ? "Yes" : "No");
    }
}
```
