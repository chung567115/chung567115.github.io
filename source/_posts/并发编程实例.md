---
title: 并发编程实例
categories: 
  - Java
tags:
  - Java
  - 并发编程
date: 2018-10-24 16:46:18
---

> 并发编程某线上代码实例

<!-- more -->


```java
/**
 * 线程池
 */
private static final ThreadPoolExecutor threadPoolExecutor = 
    new ThreadPoolExecutor(1, 10, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<>(500));

/**
 * 推送结果
 */
@Override
protected Boolean doPostAuditResult(CardApplyRecord cardApplyRecord, CardApplyCredit cardApplyCredit) {
    //校验结果是否已经推送
    CardApplyEventStream cardApplyEventStream = cardApplyEventStreamRepository.findByApplyIdAndEventId(cardApplyRecord.getApplyId(), CardApplyEventStreamEnum.PUSHED_AUDIT_RESULT_TO_BANK.value);
    if (null != cardApplyEventStream) {
    	LOGGER.info("申请记录{}信审结果已推送到银行，直接返回", cardApplyRecord.getApplyId());
    	return Boolean.TRUE;
    }

    // 设置推送中缓存
    String cacheKey = String.format(CommonConstants.CACHEKEY_PREFIX_WZBANKCARDSERVICE_POSTAUDITRESULT, cardApplyRecord.getApplyId());
    // 若存在该任务推送状态缓存，直接返回false
    if(isPostAuditResultTaskCacheExist(cacheKey)){
    	LOGGER.info("申请记录{}信审结果正在推送中，直接返回", cardApplyRecord.getApplyId());
    	return Boolean.FALSE;
    }

    Runnable runnable = new Runnable() {
    	@Override
    	public void run() {
    		runTask(cardApplyRecord, requestDO, requestXmlDO, auditResultFieldDO);
    	}
    };

    try {
    	// 记录执行状态缓存
    	cachePostAuditResultTask(cacheKey, Boolean.FALSE.toString());
    	// 异步执行推送任务
    	threadPoolExecutor.execute(runnable);
    } catch (RejectedExecutionException e) {
    	LOGGER.info("申请记录{}信审结果被任务队列丢弃，稍后重试", cardApplyRecord.getApplyId(), e);
    }
    return Boolean.FALSE;
}
```



```java
private void runTask(
	CardApplyRecord cardApplyRecord, ApplyCardRequestDO requestDO,
    ApplyCardRequestXmlDO requestXmlDO, AuditResultFieldDO auditResultFieldDO){
    
    String strLockKey = String.format(CacheConstants.LOCKKEY_UPDATE_POSTAUDITRESUT, cardApplyRecord.getApplyId());
    Boolean lockSuccess = Boolean.FALSE;

    try {
        lockSuccess = distributeLock.tryLock(strLockKey, 200);
        if (!lockSuccess) {
            throw new IgnoreStackException(org.apache.http.HttpStatus.SC_CONFLICT, "获取更新锁异常");
        }

        //校验结果是否已经推送【Double Check】
        CardApplyEventStream cardApplyEventStream = cardApplyEventStreamRepository.findByApplyIdAndEventId(
            cardApplyRecord.getApplyId(), CardApplyEventStreamEnum.PUSHED_AUDIT_RESULT_TO_BANK.value);
        if (null != cardApplyEventStream) {
            LOGGER.info("申请记录{}信审结果已推送到银行，结束任务直接返回", cardApplyRecord.getApplyId());
            return;
        }

        //发起请求
        applyCardDomainService.postAuditResult(requestDO, requestXmlDO, auditResultFieldDO);

        //保存事件流
        cardApplyEventStream = cardApplyEventStreamDomainService
            .genCardApplyEventStream4Save(cardApplyRecord.getApplyId(), CardApplyEventStreamEnum.PUSHED_AUDIT_RESULT_TO_BANK);

        Integer rowCount;
        if (null == cardApplyEventStream.getAutoId()) {
            rowCount = cardApplyEventStreamRepository.insert(cardApplyEventStream);
        } else {
            rowCount = cardApplyEventStreamRepository.update(cardApplyEventStream);
        }
        if (rowCount == 0) {
            LOGGER.error("保存设置申请{}事件流失败, 事件内容为{}", cardApplyRecord.getApplyId(),
                         CardApplyEventStreamEnum.PUSHED_AUDIT_RESULT_TO_BANK.desc);
            throw new IgnoreStackException(HttpStatus.SC_INTERNAL_SERVER_ERROR, "保存事件流失败");
        }

        // 删除推送中缓存信息
        String cacheKey = String.format(CommonConstants.CACHEKEY_PREFIX_WZBANKCARDSERVICE_POSTAUDITRESULT,
            cardApplyRecord.getApplyId());
        enniuJedisCommands.del(cacheKey);
    } catch (IgnoreStackException e) {
        if (HttpStatus.SC_INTERNAL_SERVER_ERROR == e.getHttpStatus() && StringUtils.equals("999999", e.getMessage())) {
            CreditReport creditReport = creditReportRepository.findByApplyId(cardApplyRecord.getApplyId());
            if (null != creditReport) {
                //如果已经收到了则表明已经有过一次成功了
                return;
            }
        }
        throw e;
    } finally {
        if (lockSuccess) {
            distributeLock.unlock(strLockKey);
        }
    }
}
```
