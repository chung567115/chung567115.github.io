---
title: 单例模式
categories: 
  - 设计模式
tags:
  - Java
  - 设计模式
date: 2019-01-04 13:52:05
---

> <kbd>单例模式</kbd>的目的是：保证一个类仅有一个实例，并提供一个访问它的全局访问点。

<!-- more -->

- 优点： 
1. 在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例。
2. 避免对资源的多重占用。
- 缺点：
1. 没有接口，不能继承，与单一职责原则冲突。
# 懒汉式
```java
public class Singleton {  
    private static Singleton instance;  
    private Singleton (){}  
  
    public static [synchronized] Singleton getInstance() {  
        if (instance == null) {  
            instance = new Singleton();  
        }  
        return instance;  
    }  
}
```
> 本方式中，用synchronized修饰时是线程安全的

# 饿汉式 [线程安全]
```java
public class Singleton {  
    private static Singleton instance = new Singleton();  
    private Singleton (){}
    
    public static Singleton getInstance() {  
    	return instance;  
    }  
}
```

# 双检锁 [线程安全]
```java
public class Singleton {  
    private volatile static Singleton instance;  
    private Singleton (){}
    
    public static Singleton getInstance() {  
        if (instance == null) {  //第一次检查
            synchronized (Singleton.class) {  
                if (instance == null) {  //第二次检查
                    instance = new Singleton();  
                }  
            }  
        }  
        return instance;  
    }  
}
```
>双重检查加锁机制：并不是每次进入getInstance方法都需要同步，而是先检查实例是否存在，如果不存在才进入下面的同步块，这是第一重检查。进入同步块过后，再次检查实例是否存在，如果不存在，就在同步的情况下创建一个实例，这是第二重检查。这样一来减少了多次在同步情况下进行判断所浪费的时间。

# 静态内部类 [线程安全]
```java
public class Singleton {  
    private Singleton (){}  
    
    public static final Singleton getInstance() {  
    	return SingletonHolder.INSTANCE;  
    }
    
    private static class SingletonHolder {  
    	private static final Singleton INSTANCE = new Singleton();  
    }
}
```

# 枚举类 [线程安全]
```java
public enum Singleton {  
    INSTANCE;  
    public void whateverMethod() {  
    }  
}
```
