---
title: Java面试之数据库
categories: 
  - 笔经面经
tags:
  - Java
  - 校招
date: 2018-07-21 11:13:24
---

> 笔经面经归纳汇总：数据库

<!-- more -->
# Java面试之数据库
## MySQL  
### 数据库事务  
&emsp;&emsp;数据库事务是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。事务满足以下四大特性：  

 1. **原子性（Atomicity）**：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚到事务开始前的状态。
 2.  **一致性（Consistency）**：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。
 3. **隔离性（Isolation）**：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。
 4. **持久性（Durability）**：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。


### 事务隔离级别  
&emsp;&emsp;数据读的三类问题：

| 问题  | 解释 |
|:--------:|:---:|
|脏读|事务 A 读取了事务 B 未提交的数据（发现读到的数据是脏数据） |
|  不可重复读 | 事务 A 读取了事务 B 已提交的更改数据（发现与前一次读的不一致）|
|幻读 | 事务 A 读取了事务 B 已提交的新增数据（发现之前没有这条数据的）|

&emsp;&emsp;事务的四种隔离级别见下表，MySQL默认为**REPEATABLE_READ**：  

| 隔离级别(简写) |	含义  | 隐患|
|:--------:|:---:|:---:|
|READ_UNCOMMITTED| 允许读未提交 | 脏读、不可重复读、幻读|
|READ_COMMITTED|	允许读已提交 | 不可重复读、幻读|
|REPEATABLE_READ|	允许重复读 | 幻读|
|SERIALIZABLE|	序列化读 | --|

### 存储引擎  
|   比较点  |   InnoDB   |     MyISAM    |
|:-----------:|:--------------:|:-----------------:|
|     事务   |      支持     |     不支持       |
|     外键   |      支持     |     不支持       |
|      锁      |     行锁      |     表锁          |
|     索引   | 聚集索引（数据和索引捆绑）| 非聚集索引（数据和索引分离) |
|FullText索引 | 不支持  |        支持       |
|   跨平台   |可直接拷贝|   难直接拷贝 |
|  表格压缩 |     较难     |         较易      |

#### InnoDB索引结构
&emsp;&emsp;InnoDB使用B+Tree作为索引结构，InnoDB的数据文件本身就是索引文件，**叶节点保存了完整的数据记录**。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。

![InnoDB](https://img-blog.csdnimg.cn/2018120920114072.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIxMDIxMDQ=,size_16,color_FFFFFF,t_70)

> 上图是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做<kbd>**聚集索引**</kbd>。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。

&emsp;&emsp;除此之外，InnoDB的辅助索引data域存储相应记录**主键**的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域，如下图辅助索引：


![InnoDB](https://img-blog.csdnimg.cn/20190109194055630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIxMDIxMDQ=,size_16,color_FFFFFF,t_70)
&emsp;&emsp;聚集索引这种实现方式使得按主键的搜索十分高效，但是**辅助索引搜索需要走两遍索引**：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。

> 了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。



#### MyISAM索引结构
&emsp;&emsp;MyISAM引擎也使用B+Tree作为索引结构，但具体实现方式却与InnoDB截然不同，MyISAM索引文件和数据文件是分离的，**叶节点存放的是数据记录的地址**。
![MyISAM](https://img-blog.csdnimg.cn/20181209201233879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIxMDIxMDQ=,size_16,color_FFFFFF,t_70)

&emsp;&emsp;在MyISAM中，主索引和辅助索引在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。辅助索引的结构如下图所示：

![MyISAM](https://img-blog.csdnimg.cn/20190109193935708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIxMDIxMDQ=,size_16,color_FFFFFF,t_70)
&emsp;&emsp;MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。
> MyISAM的索引方式也叫做<kbd>**非聚集索引**</kbd>，之所以这么称呼是为了与InnoDB的聚集索引区分。


### 数据库索引
&emsp;&emsp;数据库索引包括`B+树索引`、`R树索引`、`Hash索引`、`FullText索引`等。  
#### B树  
&emsp;&emsp;一棵 $m$  阶 B 树，或为空树，或满足：  
​	1. 每个结点至多有 $m$ 棵子树。
​	2. 若根结点不是叶子，则至少有两棵子树。
​	3. 除根之外的所有非终端结点至少有 $\frac{m}{2}$  棵子树。
​	4. 所有非终端结点包含 $n$ 个关键字和 $n+1$ 棵子树，$n$ 满足：$\frac{m}{2} - 1 \leq n \leq m-1$。
​	5. 所有叶子结点在同一层，不含信息，表示查找失败。

#### B+树  
&emsp;&emsp;一棵 $m$ 阶 B+ 树，或为空树，或满足：  
​	1. 根结点只有一个，分支数量范围为$[2，m]$。
​	2. 每个分支结点包含分支数范围为$[\frac{m}{2}，m]$。
​	3. 分支结点的关键字数量等于其子分支的数量减一，关键字数量范围为$[\frac{m}{2} - 1， m - 1]$，关键字**顺序递增**。
​	4. 所有叶子结点在同一层。

&emsp;&emsp;由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫。其中B树和B+树的区别如下：  

- **关键字数量不同**；B+树中 n 棵子树的结点中含有 n 个关键字；B树中 m 棵子树的结点中含有 m - 1 个关键字。
- **存储位置不同**；B+树中所有叶子结点中包含了全部关键字，且按大小顺序排列；B树的数据存储在每一个结点中，并不仅仅存储在叶子结点上。
- **分支结点构造不同**；B+树中所有非终端结点都是索引；B树中非终端结点存储数据。
- **查找方式不同**；B+树中查找时走了一条从根结点到叶子结点的路径；B树中在找到具体的数值以后就结束，并不一定到叶子结点。

> B树：有序数组+平衡多叉树； 
B+树：有序数组链表+平衡多叉树；

&emsp;&emsp;B+树的关键字全部存放在叶子节点中，非叶子节点用来做索引，而叶子节点中有一个指针指向一下个叶子节点。做这个优化的目的是为了提高**区间访问的性能**。而正是这个特性决定了B+树更适合用来存储外部数据。

#### R树（空间索引）  
&emsp;&emsp;一棵R树满足如下的性质：  
1. 除根结点之外，所有非根结点包含有 m 至 M 个记录索引，根结点的记录个数可以少于 m 。通常 M = 2m 。
2. 对于所有叶子结点中存储的记录，I 是最小的可以在空间中完全覆盖这些记录所代表的点的矩形（此处“矩形”可以扩展到高维空间）。
3. 对于所有非叶子结点上的记录，i 是最小的可以在空间上完全覆盖这些条目所代表的点的矩形。
4. 所有叶子结点在同一层。

> R树是B树在K维上的自然扩展


#### 为什么要使用B+树
&emsp;&emsp;数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。**B+树中一次检索最多需要 h-1 次 I/O（根节点常驻内存）**，渐进复杂度为$O(h)=O(\log_d N)$。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。
因此，使用B+树作为索引结构效率是非常高的。
&emsp;&emsp;而红黑树这种结构，h明显要深的多，所以红黑树的索引结构效率很低。另一方面，由于逻辑上很近的节点（父子）物理上可能很远，导致无法利用局部性一次性载入内存，所以红黑树的 I/O 也比B+树大得多。

#### 最左前缀原理
&emsp;&emsp;例如有表table，含a、b、c、d四列，有联合索引<a, b, c>。
1. 全列匹配
	```sql
	-- 当按照索引中所有列进行精确匹配（= 或 IN）时，会走索引
	SELECT * FROM t_test WHERE a='1' AND b='2' AND c='3'; -- a,b,c都走索引
	```
2. 最左前缀匹配
	```sql
	-- 当查询条件精确匹配索引的左边连续一列或几列时，会走（条件所组成的最左前缀）索引。
	SELECT * FROM t_test WHERE a='1'; -- a走索引
	SELECT * FROM t_test WHERE a='1' AND b='2'; -- a,b都走索引
	SELECT * FROM t_test WHERE a='1' AND c='3'; -- a走索引，c不走索引
	```
3. 查询条件没有指定索引第一列
	```sql
	-- 当查询条件不满足最左前缀，则不会走索引
	SELECT * FROM t_test WHERE b='2'; -- 不走索引
	SELECT * FROM t_test WHERE c='3'; -- 不走索引
	SELECT * FROM t_test WHERE b='2' AND c='3'; -- b,c都不走索引
	```
4. 匹配某列的前缀字符串
	```sql
	-- 可以用到索引，但根据具体情况不同可能只会用其中一个前缀
	SELECT * FROM t_test WHERE a='1' AND b LIKE '2%';
	```
5. 范围查询
	```sql
	-- 范围列可以用到索引（必须是最左前缀），但是范围列后面的列无法用到索引。
	-- 索引最多用于一个范围列，查询条件中有两个范围列时无法全用到索引。
	SELECT * FROM t_test WHERE a<'1' AND b='2'; -- a走索引，b不走索引
	SELECT * FROM t_test WHERE b<'2' AND c>'3'; -- b,c都不走索引
	```
6. 查询条件含函数或表达式
	```sql
	-- 如果查询条件中含有函数或表达式，MySQL不会为这列使用索引
	SELECT * FROM t_test WHERE left(a, 1)='1'; --不走索引
	SELECT * FROM t_test WHERE a='1' AND left(b, 1)='2'; -- a走索引，b不走索引
	```

### 左右连接查询 
1. 左连接(left join)：显示左表所有数据和右表相应数据。
2. 右连接(right join)：显示右表所有数据加左表相应数据。
3. 内连接(inner join)：显示有效公共数据。
4. 全连接(full join)：显示所有数据。

> **左连接只影响右表，右连接只影响左表**


## Redis  
### Redis简介  
&emsp;&emsp;基于C语言开发的一种非关系型数据库，数据放在内存，使用**RDB**[快照]方式或者**AOF**[日志]方式持久化。
&emsp;&emsp;Redis的优势包括速度、对富数据类型的支持（String、Hash、List、Set、Zset）、原子性操作、通用性。

### Redis使用场景  
- 缓存（**热数据**：经常被查询，但不常被改变的数据）
- 共享Session（SSO系统）
- 队列 / 栈
- 位操作（**大数据处理**）
- 分布式锁(**setnx命令**)与单线程机制（**秒杀系统**）
- 排行榜 / 计数器（**ZSet的zadd命令**）
- 发布 / 订阅


## 范式  
### 第一范式（1NF）  
&emsp;&emsp;所谓第一范式（1NF）是指在关系模型中，对域添加的一个规范要求，所有的域都应该是原子性的，即数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项。即实体中的某个属性有多个值时，必须拆分为不同的属性。在符合第一范式（1NF）表中的每个域值只能是实体的一个属性或一个属性的一部分。  
> 简而言之，第一范式就是无重复的域。

### 第二范式（2NF）  
&emsp;&emsp;在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖）。第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或记录必须可以被唯一地区分，选取一个能区分每个实体的属性或属性组，作为实体的唯一标识。  
> 简而言之，第二范式就是在满足第一范式的基础上，属性完全依赖于主键。

### 第三范式（3NF）  
&emsp;&emsp;在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）。第三范式（3NF）是第二范式（2NF）的一个子集，即满足第三范式（3NF）必须满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个关系中不包含已在其它关系已包含的非主关键字信息。  
> 简而言之，第三范式就是在满足第二范式的基础上，属性不依赖于其它非主属性。

## 分库后如何实现分页查询  
1. 直接使用跨库的多表联合查询（不建议）。
2. 向每个数据库均发送一个查询请求，然后对所有查询结果汇总，再处理分页逻辑。
3. 建立一个总数据库，只负责维护主键和必要的索引，以供分页查询。
4. 使用Redis维护一个主键序列，分页操作就是截取该序列的一部分，其结果就是主键ID集合，拿到ID后便可映射到多个数据库查询数据。

> “多台”数据库访问的问题无解，但同台“多次”数据库访问的问题可以通过程序优化。

## SQL注入的原理，如何预防  
&emsp;&emsp;所谓SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。  
 1. 对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双"-"进行转换等。
 2. 不要使用动态拼装SQL，应使用参数化的SQL或者直接使用存储过程进行数据查询存取。
 3. 不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
 4. 不要把机密信息明文存放，应加密或者Hash掉密码和敏感的信息。
 5. 使用自定义的错误信息对原始错误信息进行包装，把异常信息存放在独立的表中。

