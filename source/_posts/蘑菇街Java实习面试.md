---
title: 蘑菇街Java实习面试
categories: 
  - 笔经面经
tags:
  - Java
  - 蘑菇街
date: 2018-05-29 17:47:38
---

> 2018年4月17日16时20分接到蘑菇街Java实习生电话初面，面试进行了30分钟，记录如下：

<!-- more -->

# 蘑菇街Java实习面试
## 自我介绍

## Java 和 C++
| 比较点	| Java	| C++ |
|:-----:|:-----:|:-----:|
|面向对象思想	|完全对象化	|可采用非面向对象(兼容C)|
|内存管理机制	|Java自身管理|	程序员管理|
|异常机制	|完善	|欠缺|
|第三方库|	丰富(Log、JUnit等等)	|较少(STL)|
|执行效率	|慢	|快|
|操控底层	|麻烦	|方便|

## 访问网页全过程
1. 输入URL；
2. DNS将域名解析成IP地址；
3. 建立TCP连接；
4. OSPF（内部网关协议）决定经过哪些路由器，ARP（地址解析协议）负责求下一个节点地址；
5. 发送HTTP请求；
6. 得到响应，展现HTML界面。

## GET POST 区别
| 类型 |	描述 | 幂等性 |安全性|
|:-----:|:-----:|:-----:|
|POST	|向指定资源提交数据进行处理请求（例如提交表单或上传文件）|	否|	否|
|PUT	|向指定资源位置上传其最新内容 |	是|	否|
|DELETE	|请求服务器删除所标识的资源 | 是	|否|
|GET	|向特定的资源发出请求|	是	|是|

## TCP UDP HTTP

| 类型 |	TCP	| UDP | HTTP |
|:-----:|:-----:|:-----:|:-----:|
|是否连接	|面向连接	|面向非连接| 基于TCP |
|传输可靠性	|可靠|	不可靠|   -- |
|应用场合	|传输大量的数据，对可靠性要求较高的场合	|传送少量数据、对可靠性要求不高的场景| -- |
|速度	|慢	|快|  --|

## Linux常用命令
- vim命令：文本编辑
- gcc命令：编译
- ps命令：进程运行情况
- kill命令：停止进程
- atop / htop命令：查看内存使用情况

## Redis
&emsp;&emsp;基于C语言开发的一种非关系型数据库，数据放在内存，使用RDB[快照]方式或者AOF[日志]方式持久化。 Redis的优势包括速度、对富数据类型的支持（String、Hash、List、Set、Zset）、原子性操作、通用性。

## RabbitMQ
&emsp;&emsp;消息队列中间件是分布式系统中重要的组件，主要主要解决应用耦合、异步消息、流量削锋等问题，具有异步性、可靠性（存储到本地硬盘）、松耦合、分布式的特性。

- 主要特点是异步处理
- 主要目的是减少请求响应时间、解耦
- 主要使用场景是将比较耗时且不需同步返回结果的操作当做消息存入队列

## Nginx
- 正向代理：隐藏真实的请求客户端，服务端不知道真实的客户端是谁，正向代理服务器会代替客户端向服务器发送请求。正向代理代理的对象是客户端。
- 反向代理：隐藏真实的响应服务端，客户端不知道真实的服务端是谁，反向代理服务器会把请求转发到真实的服务器。反向代理代理的对象是服务端。

> 10086总机就是一种反向代理，客户不知道真正提供服务人的是谁。

## Spring Boot 启动流程（不会）
参考博文 https://www.cnblogs.com/zheting/p/6707035.html
![Spring Boot 启动流程](https://img-blog.csdn.net/20180418105832948?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIxMDIxMDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

## 自定义starter（不会）
参考博文 https://blog.csdn.net/liuchuanhong1/article/details/55057135

## 多线程
&emsp;&emsp;实现多线程的几种方式

- 继承Thread类创建线程
- 实现Callable接口创建线程
- 实现Runnable接口创建新线程(可用Future返回结果)

## ThreadLocal
&emsp;&emsp;设计理念是为了减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。作用是提供线程内部的局部变量，这些变量在多线程环境下访问(get/set)时能保证与其它线程里的变量相对独立。打个比方，多人(多个线程)使用自己的交通卡(线程私有变量)乘公交转地铁(两个函数)。

> synchronized用于线程间的数据共享，而ThreadLocal则用于线程间的数据隔离。

## ThreadLocal 不清空会有什么影响（答得不好）
&emsp;&emsp;如果使用了线程池，那么即使即使父线程已经结束，子线程依然存在并被池化。这样，线程池中的线程在下一次请求被执行的时候，ThreadLocal 对象的 get() 方法返回的将不是当前线程中设定的变量，因为池中的子线程根本不是当前线程创建的，当前线程设定的 ThreadLocal 变量也就无法传递给线程池中的线程。
&emsp;&emsp;因此，必须将外部线程中的 ThreadLocal 变量显式地传递给线程池中的线程，或者每个请求来的时候先 threadLocal.set(null) 。

## ThreadPool
&emsp;&emsp;使用线程池的优势：

- 降低资源消耗：重复利用已创建的线程，降低创建和销毁造成的消耗。
- 提高响应速度：任务可以不需要等到线程创建就能立即执行(参考上条)。
- 提高管理性：可以进行统一的分配、调优和监控。

## 有什么问题要问的

