<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>博学de叫兽</title>
  
  <subtitle>博学之，审问之</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhangchong.xin/"/>
  <updated>2019-03-09T11:22:46.906Z</updated>
  <id>http://zhangchong.xin/</id>
  
  <author>
    <name>张冲</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用Hexo在GitHub上搭建私人博客</title>
    <link href="http://zhangchong.xin/2019/03/09/%E4%BD%BF%E7%94%A8Hexo%E5%9C%A8GitHub%E4%B8%8A%E6%90%AD%E5%BB%BA%E7%A7%81%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://zhangchong.xin/2019/03/09/使用Hexo在GitHub上搭建私人博客/</id>
    <published>2019-03-09T10:43:22.000Z</published>
    <updated>2019-03-09T11:22:46.906Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>光速搭建个人免费博客</p></blockquote><a id="more"></a><!-- more -->]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;光速搭建个人免费博客&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="建站运维" scheme="http://zhangchong.xin/categories/%E5%BB%BA%E7%AB%99%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Hexo" scheme="http://zhangchong.xin/tags/Hexo/"/>
    
      <category term="GitHub" scheme="http://zhangchong.xin/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>Java面试之旅</title>
    <link href="http://zhangchong.xin/2018/09/03/Java%20%E9%9D%A2%E8%AF%95%E4%B9%8B%E6%97%85/"/>
    <id>http://zhangchong.xin/2018/09/03/Java 面试之旅/</id>
    <published>2018-09-03T07:41:22.000Z</published>
    <updated>2019-03-12T19:36:56.438Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>校招笔经面经汇总</p></blockquote><a id="more"></a><h1 id="小博Spring-Boot快速入门GitChat"><a href="#小博Spring-Boot快速入门GitChat" class="headerlink" title="小博Spring Boot快速入门GitChat"></a>小博Spring Boot快速入门GitChat</h1><p><a href="https://gitbook.cn/gitchat/activity/5a444c451f6ee91a25846ac1" target="_blank" rel="noopener">https://gitbook.cn/gitchat/activity/5a444c451f6ee91a25846ac1</a></p><h1 id="小博Java面试路上的点点滴滴"><a href="#小博Java面试路上的点点滴滴" class="headerlink" title="小博Java面试路上的点点滴滴"></a>小博Java面试路上的点点滴滴</h1><table><thead><tr><th>篇章</th><th>小博博客地址</th></tr></thead><tbody><tr><td>Java 面试之基础篇</td><td><a href="http://zhangchong.xin/2018/08/28/Java%20%E9%9D%A2%E8%AF%95%E4%B9%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/">点击跳转</a></td></tr><tr><td>Java 面试之框架篇</td><td><a href="http://zhangchong.xin/2018/08/28/Java%20%E9%9D%A2%E8%AF%95%E4%B9%8B%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/">点击跳转</a></td></tr><tr><td>Java 面试之数据结构篇</td><td><a href="http://zhangchong.xin/2018/08/28/Java%20%E9%9D%A2%E8%AF%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">点击跳转</a></td></tr><tr><td>Java 面试之JVM篇</td><td><a href="http://zhangchong.xin/2018/09/03/Java%20%E9%9D%A2%E8%AF%95%E4%B9%8B%20JVM/">点击跳转</a></td></tr><tr><td>Java 面试之多线程篇</td><td><a href="http://zhangchong.xin/2018/09/03/Java%20%E9%9D%A2%E8%AF%95%E4%B9%8B%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%94%81/">点击跳转</a></td></tr><tr><td>Java 面试之数据库篇</td><td><a href="http://zhangchong.xin/2018/07/21/Java%20%E9%9D%A2%E8%AF%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93/">点击跳转</a></td></tr><tr><td>Java 面试之计算机网络篇</td><td><a href="http://zhangchong.xin/2018/07/21/Java%20%E9%9D%A2%E8%AF%95%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">点击跳转</a></td></tr><tr><td>Java 面试之操作系统篇</td><td><a href="http://zhangchong.xin/2018/07/21/Java%20%E9%9D%A2%E8%AF%95%E4%B9%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">点击跳转</a></td></tr><tr><td>Java 面试之算法篇</td><td><a href="http://zhangchong.xin/2018/07/21/Java%20%E9%9D%A2%E8%AF%95%E4%B9%8B%E7%AE%97%E6%B3%95/">点击跳转</a></td></tr><tr><td>Java 面试之附加篇</td><td><a href="http://zhangchong.xin/2018/08/28/Java%20%E9%9D%A2%E8%AF%95%E4%B9%8B%E7%BB%93%E6%9D%9F%E9%97%AE%E7%AD%94/">点击跳转</a></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;校招笔经面经汇总&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="笔经面经" scheme="http://zhangchong.xin/categories/%E7%AC%94%E7%BB%8F%E9%9D%A2%E7%BB%8F/"/>
    
    
      <category term="Java" scheme="http://zhangchong.xin/tags/Java/"/>
    
      <category term="校招" scheme="http://zhangchong.xin/tags/%E6%A0%A1%E6%8B%9B/"/>
    
  </entry>
  
  <entry>
    <title>Java面试之JVM</title>
    <link href="http://zhangchong.xin/2018/09/03/Java%20%E9%9D%A2%E8%AF%95%E4%B9%8B%20JVM/"/>
    <id>http://zhangchong.xin/2018/09/03/Java 面试之 JVM/</id>
    <published>2018-09-03T07:23:03.000Z</published>
    <updated>2019-03-12T11:21:14.417Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>笔经面经归纳汇总：Java虚拟机</p></blockquote><a id="more"></a><h1 id="Java面试之JVM"><a href="#Java面试之JVM" class="headerlink" title="Java面试之JVM"></a>Java面试之JVM</h1><h2 id="JVM结构图"><a href="#JVM结构图" class="headerlink" title="JVM结构图"></a>JVM结构图</h2><p><img src="https://raw.githubusercontent.com/chung567115/chung567115.github.io/hexo-blog/blog-img/39-1.png" alt="JVM"></p><h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><h3 id="类加载的五个过程"><a href="#类加载的五个过程" class="headerlink" title="类加载的五个过程"></a>类加载的五个过程</h3><ul><li><kbd>加载</kbd>：类加载器获二进制字节流，将静态存储结构转化为方法区的运行时数据结构，并生成此类的Class对象。</li><li><kbd>验证</kbd>：验证文件格式、元数据、字节码、符号引用，确保Class的字节流中包含的信息符合当前虚拟机的要求。</li><li><kbd>准备</kbd>：为类变量分配内存并设置其初始值，这些变量使用的内存都将在方法区中进行分配。</li><li><kbd>解析</kbd>：将常量池内的符号引用替换为直接引用，包括类或接口的解析、字段解析、类方法解析、接口方法解析。</li><li><p><kbd>初始化</kbd>：执行类中定义的Java程序代码（字节码）。</p><blockquote><p>类的生命周期(7个)：加载、验证、准备、解析、初始化、使用、卸载</p></blockquote></li></ul><h3 id="Java类加载器及如何加载类"><a href="#Java类加载器及如何加载类" class="headerlink" title="Java类加载器及如何加载类"></a>Java类加载器及如何加载类</h3><p>&emsp;&emsp;<strong>类加载器</strong>是实现<strong>通过一个类的全限定名来获取描述此类的二进制文件流</strong>的代码模块。类的加载是通过双亲委派模型来完成的，<strong>双亲委派模型</strong>即为下图所示的<strong>类加载器之间的层次关系</strong>。<br>&emsp;&emsp;双亲委派模型的工作过程是：如果一个类加载器接收到类加载的请求，它会先把这个请求委派给父加载器去完成，只有当父加载器反馈自己无法完成加载请求时，子加载器才会尝试自己去加载。可以得知，<strong>所有的加载请求最终都会传送到启动类加载器中</strong>。  </p><p><img src="https://raw.githubusercontent.com/chung567115/chung567115.github.io/hexo-blog/blog-img/39-2.png" alt="双亲委派模型"></p><blockquote><p>使用双亲委派模型组织类加载器之间的关系有一个显而易见的好处：<strong>Java类随着它的类加载器一起具备了某种带优先级的层次关系</strong>。如果没有使用双亲委派模型，而是由各类加载器自行加载，假如用户自己编写一个Object类放在ClassPath中，那么系统将会出现多个不同的Object类，Java体系中最基础的行为也就无法保证，应用程序将变得一片混乱。</p></blockquote><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><h3 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h3><ul><li><strong>Java堆</strong>：Java虚拟机所管理的内存中最大的一块，唯一的目的是存放对象实例。由于是垃圾收集器管理的主要区域，因此有时候也被称作<code>GC堆</code>。</li><li><strong>方法区</strong>：用于存储已被虚拟机加载的类信息、常量、静态变量、及时编译器编译后的代码等数据。</li><li><strong>程序计数器</strong>：当前线程所执行字节码的行号指示器。每一个线程都有一个独立的程序计数器，线程的阻塞、恢复、挂起等一系列操作都需要程序计数器的参与，因此必须是线程私有的。</li><li><strong>Java虚拟机栈</strong>：用于描述Java方法执行的模型。每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。<code>每一个方法从调用至执行完成，对应于一个栈帧在虚拟机栈中从入栈到出栈</code>。</li><li><p><strong>本地方法栈</strong>：与虚拟机栈作用相似，只不过虚拟机栈为执行Java方法服务，而本地方法栈为执行Native方法服务，比如在Java中调用C/C++。</p><p>  <img src="https://raw.githubusercontent.com/chung567115/chung567115.github.io/hexo-blog/blog-img/39-3.png" alt="Java虚拟机运行时数据区"></p></li></ul><h3 id="JVM内存分代机制，各代特点，分代回收优点"><a href="#JVM内存分代机制，各代特点，分代回收优点" class="headerlink" title="JVM内存分代机制，各代特点，分代回收优点"></a>JVM内存分代机制，各代特点，分代回收优点</h3><ul><li><strong>新生代（Young）</strong>：HotSpot将新生代划分为三块，一块较大的Eden空间和两块较小的Survivor空间，默认比例为<code>8：1：1</code>。</li><li><strong>老年代（Old）</strong>：在新生代中经历了多次GC后仍然存活下来的对象会进入老年代中。老年代中的对象生命周期较长，存活率比较高，在老年代中进行GC的频率相对而言较低，而且回收的速度也比较慢。</li><li><p><strong>永久代（Permanent）</strong>：永久代存储类信息、常量、静态变量、即时编译器编译后的代码等数据，对这一区域而言，一般而言不会进行垃圾回收。</p><blockquote><p>新版已经删除永久代。</p></blockquote><p>  <img src="https://raw.githubusercontent.com/chung567115/chung567115.github.io/hexo-blog/blog-img/39-4.png" alt="JVM共享数据空间划分图"></p><p>  &emsp;&emsp;新生成的对象在Eden区分配（大对象除外，大对象直接进入老年代），<strong>当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC</strong>。GC开始时，对象只会存在于Eden区和From Survivor区，To Survivor区是空的（作为保留区域）。GC进行时，Eden区中所有存活的对象都会被复制到To Survivor区，而在From Survivor区中，仍存活的对象会根据它们的年龄值决定去向，年龄值达到年龄阀值（默认为15，新生代中的对象每熬过一轮垃圾回收，年龄值就加1，GC分代年龄存储在对象的Header中）的对象会被移到老年代中，没有达到阀值的对象会被复制到To Survivor区。接着清空Eden区和From Survivor区，新生代中存活的对象都在To Survivor区。接着， From Survivor区和To Survivor区会交换它们的角色，也就是新的To Survivor区就是上次GC清空的From Survivor区，新的From Survivor区就是上次GC的To Survivor区，总之，不管怎样都会保证To Survivor区在一轮GC后是空的。GC时当To Survivor区没有足够的空间存放上一次新生代收集下来的存活对象时，需要依赖老年代进行分配担保，将这些对象存放在老年代中。  </p></li></ul><h3 id="常用的内存调试工具"><a href="#常用的内存调试工具" class="headerlink" title="常用的内存调试工具"></a>常用的内存调试工具</h3><ul><li>JConsole（可视化工具，可排查死锁、生成Heap Dump文件等）</li><li>Jmap</li><li>jstack</li></ul><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>&emsp;&emsp;垃圾回收需要完成的三件事：①哪些内存需要回收；②什么时候回收；③如何回收。  </p><h3 id="哪些内存需要回收"><a href="#哪些内存需要回收" class="headerlink" title="哪些内存需要回收"></a>哪些内存需要回收</h3><ul><li>堆</li><li>方法区</li></ul><h3 id="什么时候回收"><a href="#什么时候回收" class="headerlink" title="什么时候回收"></a>什么时候回收</h3><ul><li><strong>引用计数算法</strong>：给对象添加一个引用计数器，每当有一个地方引用它时，计数器加1，每当一个引用失效时，计数器减1，任何时刻计数器为0则代表对象不被引用。<blockquote><p>注意：引用计数算法有一个比较大的问题，那就是它不能处理环形数据。即如果有两个对象相互引用，那么这两个对象计数器始终不为0，也就不能被回收。</p></blockquote></li><li><strong>可达性分析算法</strong>：设立若干根对象（GC Roots），每个对象都是一个子节点。从根向下搜索所走过的路径叫<code>引用链</code>，当一个对象到根无任何引用链相连，证明此对象不可用。<br>  &emsp;&emsp;Java语言中可以作为GC Roots的对象包括以下几种：  <ul><li>虚拟机栈中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中<code>JNI</code>引用的对象</li></ul></li></ul><h3 id="如何回收"><a href="#如何回收" class="headerlink" title="如何回收"></a>如何回收</h3><ul><li><strong>标记-清除算法</strong>：先标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象。</li><li><strong>复制算法</strong>：将可用内存分为大小相等的两块，每次只使用其中一块，当这一块内存用完了，就将存活的对象复制到另一块，最后将此块内存一次性清理掉。</li><li><strong>标记-整理算法</strong>：先标记所有需要回收的对象，然后让所有存活的对象向一端移动，最后直接清理掉边界以外的另一端内存。</li><li><strong>分代收集算法</strong>：把Java堆分为新生代和老年代。新生代中只有少量对象会存活，就选用<code>复制</code>算法；老年代中对象存活率较高，选用<code>标记-XX</code>算法。</li></ul><h3 id="垃圾收集器有哪些"><a href="#垃圾收集器有哪些" class="headerlink" title="垃圾收集器有哪些"></a>垃圾收集器有哪些</h3><ul><li><strong>Serial收集器</strong>：单线程收集器。收集垃圾时必须暂停其他所有工作线程，直到它收集结束。</li><li><strong>Parnew收集器</strong>：Serial收集器多线程版本。</li><li><strong>Parallel Scavenge收集器</strong>：使用复制算法的新生代收集器。</li><li><strong>Serial Old收集器</strong>：使用标记-整理算法的老年代单线程收集器。</li><li><strong>Parallel Old收集器</strong>：使用标记-整理算法的老年代多线程收集器。</li><li><strong>CMS收集器</strong>：基于标记-清除算法的低停顿并发收集器。运作步骤为①初始标记②并发标记③重新标记④并发清除。</li><li><strong>G1收集器</strong>：最前沿的面向服务端应用的垃圾收集器。运作步骤为①初始标记②并发标记③最终标记④筛选回收。G1收集器有以下特点<ul><li>并行与并发：无需停顿Java线程来执行GC动作。</li><li>分代收集：可独立管理整个GC堆。</li><li>空间整合：运行期间不会产生内存空间碎片。</li><li>可预测的停顿：除了低停顿，还能建立可预测的停顿时间模型。</li></ul></li></ul><h3 id="Minor-GC与Full-GC"><a href="#Minor-GC与Full-GC" class="headerlink" title="Minor GC与Full GC"></a>Minor GC与Full GC</h3><ul><li>新生代 GC（Minor GC）：指发生在新生代的垃圾收集动作，因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。</li><li>老年代 GC（Major GC  / Full GC）：指发生在老年代的垃圾收集动作，出现了 Major GC，经常会伴随至少一次 Minor GC（非绝对），MajorGC 的速度一般会比 Minor GC 慢10倍以上。</li></ul><p>&emsp;&emsp;Minor GC与Full GC触发条件：  </p><ul><li>Minor GC触发条件：<ul><li>当Eden区没有足够的空间进行分配时</li><li>老年代最大可用连续空间<strong>大于</strong>Minor GC历次晋升到老年代对象的平均大小</li></ul></li><li>Full GC触发条件：<ul><li>调用System.gc()时（系统建议执行Full GC，但是不必然执行）</li><li>老年代空间不足时</li><li>方法区空间不足时</li><li>老年代最大可用连续空间<strong>小于</strong>Minor GC历次晋升到老年代对象的平均大小</li><li>CMS GC在垃圾回收的时候，当对象从Eden区进入Survivor区，Survivor区空间不足需要放入老年代，而老年代空间也不足时</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;笔经面经归纳汇总：Java虚拟机&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="笔经面经" scheme="http://zhangchong.xin/categories/%E7%AC%94%E7%BB%8F%E9%9D%A2%E7%BB%8F/"/>
    
    
      <category term="Java" scheme="http://zhangchong.xin/tags/Java/"/>
    
      <category term="校招" scheme="http://zhangchong.xin/tags/%E6%A0%A1%E6%8B%9B/"/>
    
  </entry>
  
  <entry>
    <title>Java面试之线程与锁</title>
    <link href="http://zhangchong.xin/2018/09/03/Java%20%E9%9D%A2%E8%AF%95%E4%B9%8B%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%94%81/"/>
    <id>http://zhangchong.xin/2018/09/03/Java 面试之线程与锁/</id>
    <published>2018-09-03T07:22:51.000Z</published>
    <updated>2019-03-12T18:50:29.120Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>笔经面经归纳汇总：多线程和锁</p></blockquote><a id="more"></a><h1 id="Java面试之线程与锁"><a href="#Java面试之线程与锁" class="headerlink" title="Java面试之线程与锁"></a>Java面试之线程与锁</h1><h2 id="进程、线程"><a href="#进程、线程" class="headerlink" title="进程、线程"></a>进程、线程</h2><p>&emsp;&emsp;<strong>进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元</strong>。一个进程一般包括多个线程，这些线程共享本进程的内存和资源。</p><h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p><img src="https://raw.githubusercontent.com/chung567115/chung567115.github.io/hexo-blog/blog-img/38-1.png" alt="线程状态"></p><h3 id="实现线程的几种方式"><a href="#实现线程的几种方式" class="headerlink" title="实现线程的几种方式"></a>实现线程的几种方式</h3><ul><li>继承Thread类创建线程</li><li>实现Runnable接口创建线程</li><li>实现Callable接口创建新线程(可用Future返回结果)</li></ul><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>&emsp;&emsp;设计理念是为了减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。作用是提供线程内部的局部变量，这些变量在多线程环境下访问(get/set)时能保证与其它线程里的变量相对独立。打个比方，多人(多个线程)使用自己的交通卡(线程私有变量)乘公交转地铁(两个函数)。<br>&emsp;&emsp;注意：使用 ThreadLocal 时要保证能够管理它的创建、销毁，否则会出问题。因为 ThreadLocal 是和 Thread 绑定的，如果 Thread 是从 ThreadPool 中拿出来的，那么意味着 Thread 可能会被复用。如果被复用，你就一定得保证这个 Thread 上一次结束的时候，其关联的 ThreadLocal 被清空掉，否则就会串到下一次使用。</p><blockquote><p>应用场景：银行转账包含一系列的操作，把转出账户的余额减少，把转入账户的余额增加，这两个操作要在同一个事务中完成，它们必须使用相同的数据库连接对象，而这个连接信息可以用ThreadLocal保存。</p></blockquote><h4 id="ThreadPool的用法"><a href="#ThreadPool的用法" class="headerlink" title="ThreadPool的用法"></a>ThreadPool的用法</h4><p>&emsp;&emsp;使用ThreadPoolExecutor创建线程池，其中5参构造函数参数列表如下：</p><ul><li>int corePoolSize：线程池中核心线程数，一般为cpu数量</li><li>int maximumPoolSize： 线程池中线程总数，一般为2*cpu数量(<code>I/O密集型时maxSize设置大一点，提高cpu利用率</code>)</li><li>long keepAliveTime：线程池中非核心线程闲置超时时长</li><li>TimeUnit unit：keepAliveTime的单位</li><li>BlockingQueue workQueue：线程池中的任务队列，维护着等待执行的Runnable对象 <ul><li>SynchronousQueue：接收到任务时，会直接提交给线程处理，而不保留它</li><li>LinkedBlockingQueue：接收到任务时，如果当前线程数小于核心线程数，则新建核心线程处理任务；如果当前线程数等于核心线程数，则进入队列等待</li><li>ArrayBlockingQueue：接收到任务时，如果没有达到corePoolSize的值，则新建核心线程执行任务；如果达到了，则入队等候；如果队列已满，则新建非核心线程执行任务；如果总线程数到了maximumPool，且队列也满了，则发生错误</li><li>DelayQueue：接收到任务时，首先先入队，只有达到了指定的延时时间，才会执行任务。注意：队列内元素必须实现Delayed接口，这就意味着你传进去的任务必须先实现Delayed接口</li></ul></li><li><p>RejectedExecutionHandler handler：BlockingQueue 打满时的几种拒绝策略</p><ul><li>Abort策略：默认策略，新任务提交时直接抛出未检查的异常</li><li>RejectedExecutionException，该异常可由调用者捕获</li><li>CallerRuns策略：为调节机制，既不抛弃任务也不抛出异常，而是将某些任务回退到调用者。不会在线程池的线程中执行新的任务，而是在调用exector的线程中运行新的任务</li><li>Discard策略：新提交的任务被抛弃</li><li><p>DiscardOldest策略：队列的是“队头”的任务，然后尝试提交新的任务</p><blockquote><p>向线程池提交一个要执行的任务<code>threadPoolExecutor.execute(runnable);</code></p></blockquote></li></ul></li></ul><p>&emsp;&emsp;当新提交一个任务时：</p><ol><li>如果<code>当前线程数&lt;corePoolSize</code>，新增一个核心线程处理新的任务</li><li>如果<code>当前线程数=corePoolSize</code>，新任务会被放入阻塞队列等待</li><li>如果阻塞队列满了，且<code>当前线程数&lt;maximumPoolSize</code>，新增线程来处理任务</li><li>如果阻塞队列满了，且<code>当前线程数=maximumPoolSize</code>，那么线程池已达极限，此时会根据饱和策略<code>RejectedExecutionHandler</code>拒绝新任务<h3 id="使用线程池的优势："><a href="#使用线程池的优势：" class="headerlink" title="使用线程池的优势："></a>使用线程池的优势：</h3></li></ol><ul><li>降低资源消耗：重复利用已创建的线程，降低创建和销毁造成的消耗。</li><li>提高响应速度：任务可以不需要等到线程创建就能立即执行(参考上条)。</li><li>提高管理性：可以进行统一的分配、调优和监控。</li></ul><h3 id="三大常用并发工具类"><a href="#三大常用并发工具类" class="headerlink" title="三大常用并发工具类"></a>三大常用并发工具类</h3><ul><li>Semaphore：并发控制，控制刷新账单并发数，tryAcquire()、release()</li><li>CountDownLanch：计数器，与会人员到齐了会议才能开始，await()、countDown()</li><li>Cyclicbarrier：同步屏障(可以被重用)，等待本周每天的账单都计算完之后，再计算日均开销，await()</li></ul><h3 id="concurrent包"><a href="#concurrent包" class="headerlink" title="concurrent包"></a>concurrent包</h3><ul><li>Executor接口：具体Runnable任务的执行者。</li><li>Executors类：创建线程池工具类（阿里手册禁止用此工具类）。</li><li>ExecutorService接口：线程池管理者，可提交Runnable、Callable让其调度。</li><li>ThreadPoolExecutor类：线程池工具类。（ExecutorService的一种具体实现）。</li><li>CompletionService接口：ExecutorService的扩展，可以获得线程执行结果。</li><li>ReentrantLock类：可重入互斥锁（实现Lock接口）。</li><li>BlockingQueue接口：阻塞队列。</li><li>Future接口：一个线程执行结束后取返回的结果，还提供了cancel()终止线程。</li><li>CountDownLatch类：当计数器值到达0时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。</li></ul><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h3><ul><li><strong>互斥条件</strong>：进程对所分配的资源进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</li><li><strong>不剥夺条件</strong>：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程主动释放。</li><li><strong>请求和保持条件</strong>：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</li><li><strong>环路等待条件</strong>：存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。</li></ul><h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><ul><li>加锁顺序（线程按一定顺序加锁，若所有线程都按相同顺序获得锁，就能避免死锁） </li><li>加锁时限（线程获取锁时加上时限，超时则放弃并释放所占有的锁，就能避免死锁）</li><li>死锁检测（一个更优的预防机制，主要针对不可能实现按序加锁和加锁时限的场景）</li></ul><h3 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h3><table><thead><tr><th style="text-align:center">锁</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">公平锁/非公平锁</td><td style="text-align:center">公平锁是指多个线程按照申请锁的顺序来获取锁</td></tr><tr><td style="text-align:center">可重入锁</td><td style="text-align:center">同一线程在外层方法已获取锁时，进入内层方法会自动获取锁</td></tr><tr><td style="text-align:center">独享锁/共享锁</td><td style="text-align:center">一次可被<strong>单个/多个</strong>线程所持有，例如ReadWriteLock的<strong>写锁/读锁</strong></td></tr><tr><td style="text-align:center">互斥锁/读写锁</td><td style="text-align:center">一种互斥锁：ReentrantLock；一种读写锁：ReadWriteLock</td></tr><tr><td style="text-align:center">乐观锁/悲观锁</td><td style="text-align:center">悲观锁认为对于同一个数据的并发操作一定会发生修改</td></tr><tr><td style="text-align:center">分段锁</td><td style="text-align:center">一种锁的设计，具体应用有ConcurrentHashMap</td></tr><tr><td style="text-align:center">自旋锁</td><td style="text-align:center">尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取</td></tr><tr><td style="text-align:center">偏向锁/轻量级锁/重量级锁</td><td style="text-align:center">指锁的状态，并且是针对synchronized</td></tr></tbody></table><blockquote><p><strong>偏向锁</strong>是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。<strong>轻量级锁</strong>是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。<strong>重量级锁</strong>是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但当自旋一定次数还没获取到锁的时候，就会进入阻塞，该锁膨胀为重量级锁。</p></blockquote><h3 id="各种比较"><a href="#各种比较" class="headerlink" title="各种比较"></a>各种比较</h3><h4 id="synchronized和volatile"><a href="#synchronized和volatile" class="headerlink" title="synchronized和volatile"></a>synchronized和volatile</h4><ol><li><p>synchronized是Java中的关键字，是一种同步锁。有如下几种用法：  </p> <div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 修饰方法(方法锁)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//doSomething</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 修饰代码块(对象锁)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">synMethod</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(arg) &#123;</span><br><span class="line">        <span class="comment">//doSomething</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//3. 修饰类(类锁)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(SyncClass.class) &#123;</span><br><span class="line">            <span class="comment">//doSomething</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><blockquote><p>锁的级别有对象级别和类级别，1和2属于对象级别，3属于类级别</p></blockquote></li><li><p>volatile 是在告诉JVM当前变量在cpu缓存中的值是不确定的，需要从主存中读取（<strong>禁止指令的重排序</strong>）； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。volatile与synchronized的区别如下：  </p></li></ol><table><thead><tr><th style="text-align:center">比较点</th><th style="text-align:center">volatile</th><th style="text-align:center">synchronized</th></tr></thead><tbody><tr><td style="text-align:center">阻塞</td><td style="text-align:center">不会发生线程阻塞</td><td style="text-align:center">会发生线程阻塞</td></tr><tr><td style="text-align:center">修饰</td><td style="text-align:center">变量</td><td style="text-align:center">方法、代码块、类</td></tr><tr><td style="text-align:center">原子性</td><td style="text-align:center">不能保证</td><td style="text-align:center">可以保证</td></tr><tr><td style="text-align:center">安全性</td><td style="text-align:center">非线程安全</td><td style="text-align:center">线程安全</td></tr><tr><td style="text-align:center">解决问题</td><td style="text-align:center">变量在多线程之间的可见性</td><td style="text-align:center">多线程之间访问资源的同步性</td></tr></tbody></table><h4 id="sychronized和Lock"><a href="#sychronized和Lock" class="headerlink" title="sychronized和Lock"></a>sychronized和Lock</h4><table><thead><tr><th style="text-align:center">比较点</th><th style="text-align:center">sychronized</th><th style="text-align:center">Lock</th></tr></thead><tbody><tr><td style="text-align:center">解释</td><td style="text-align:center">Java关键字</td><td style="text-align:center">Java接口</td></tr><tr><td style="text-align:center">显隐</td><td style="text-align:center">隐式锁</td><td style="text-align:center">需显示指定起始位置和终止位置</td></tr><tr><td style="text-align:center">释放锁</td><td style="text-align:center">获取锁的线程会在执行完同步代码后自动释放锁（或者JVM会在线程执行发生异常时释放锁）</td><td style="text-align:center">在finally中必须释放锁，不然容易造成线程死锁</td></tr><tr><td style="text-align:center">等待</td><td style="text-align:center">一个线程获得锁后阻塞，其他线程会一直等待</td><td style="text-align:center">线程不会一直等待，超时会释放</td></tr><tr><td style="text-align:center">锁类型</td><td style="text-align:center">可重入但不可中断、非公平</td><td style="text-align:center">可重入、可中断、可公平也可不公平</td></tr></tbody></table><h4 id="sleep-和wait-，yield-和notify"><a href="#sleep-和wait-，yield-和notify" class="headerlink" title="sleep()和wait()，yield()和notify()"></a>sleep()和wait()，yield()和notify()</h4><ul><li>sleep()是Thread类的一个静态函数，它会使调用线程睡眠(阻塞)一段时间，让其他线程有机会继续执行，但它<strong>不释放锁</strong>。</li><li>wait()是Object类的方法，它会使当前线程阻塞，直到调用notify()，则被唤醒，它<strong>会释放锁</strong>。</li><li>yield()是Thread类的方法，它会使运行中的线程重新变为就绪状态，让同优先级线程重新竞争。</li><li>notify()是Object类的方法，它会唤醒单个线程。</li></ul><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>&emsp;&emsp;一种跨服务器(JVM)控制共享资源访问的互斥机制。在分布式系统环境下，一个方法在同一时间只能被一台机器的一个线程执行。  </p><ol><li><strong>基于数据库实现分布式锁</strong>：在数据库中创建一张表，表中包含<strong>方法名</strong>字段，并在方法名字段上创建唯一索引，想要执行某个方法，就使用这个方法名向表中插入数据，成功插入则获取锁，执行完成后删除对应的行数据释放锁。</li><li><p><strong>基于缓存（Redis等）实现分布式锁</strong>：获取锁的时候，使用<strong>setnx</strong>加锁，并使用<strong>expire</strong>命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的value值为当前时间加上锁定时间，释放锁的时候执行<strong>delete</strong>进行释放。</p><blockquote><p>Redis实现分布式锁详见小博另一篇博客:&emsp;<a href="https://blog.csdn.net/u012102104/article/details/82966553" target="_blank" rel="noopener">点击查看</a></p></blockquote></li><li><strong>基于Zookeeper实现分布式锁</strong>：①创建一个目录dislock；②线程A想获取锁就在dislock目录下创建临时顺序节点；③获取dislock目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；④线程B获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；⑤线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;笔经面经归纳汇总：多线程和锁&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="笔经面经" scheme="http://zhangchong.xin/categories/%E7%AC%94%E7%BB%8F%E9%9D%A2%E7%BB%8F/"/>
    
    
      <category term="Java" scheme="http://zhangchong.xin/tags/Java/"/>
    
      <category term="校招" scheme="http://zhangchong.xin/tags/%E6%A0%A1%E6%8B%9B/"/>
    
  </entry>
  
  <entry>
    <title>Java面试之结束问答</title>
    <link href="http://zhangchong.xin/2018/08/28/Java%20%E9%9D%A2%E8%AF%95%E4%B9%8B%E7%BB%93%E6%9D%9F%E9%97%AE%E7%AD%94/"/>
    <id>http://zhangchong.xin/2018/08/28/Java 面试之结束问答/</id>
    <published>2018-08-28T07:12:53.000Z</published>
    <updated>2019-03-11T16:24:37.183Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>笔经面经归纳汇总：结束问答</p></blockquote><a id="more"></a><h1 id="Java面试之结束问答"><a href="#Java面试之结束问答" class="headerlink" title="Java面试之结束问答"></a>Java面试之结束问答</h1><h2 id="技术优化"><a href="#技术优化" class="headerlink" title="技术优化"></a>技术优化</h2><h3 id="线程池优化"><a href="#线程池优化" class="headerlink" title="线程池优化"></a>线程池优化</h3><ul><li>设置最大线程数</li><li>设置最小核心线程数</li><li>设置额外线程存活时间</li><li>选择线程池队列</li><li>选择合适的线程池</li><li>选择合适的饱和策略</li></ul><h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><ul><li>尽量不要锁住方法</li><li>缩小同步代码块，只锁数据</li><li>锁中尽量不要再包含锁</li><li>将锁私有化，在内部管理锁</li><li>进行适当的锁分解</li></ul><h3 id="HTTP-1-1-rightarrow-HTTP-2-0"><a href="#HTTP-1-1-rightarrow-HTTP-2-0" class="headerlink" title="HTTP 1.1 $\rightarrow$ HTTP 2.0"></a>HTTP 1.1 $\rightarrow$ HTTP 2.0</h3><ul><li><p>Tomcat 在 server.xml 里配置HTTP 协议版本</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8443"</span> <span class="attr">protocol</span>=<span class="string">"org.apache.coyote.http11.Http11AprProtocol"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">maxThreads</span>=<span class="string">"150"</span> <span class="attr">SSLEnabled</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">UpgradeProtocol</span> <span class="attr">className</span>=<span class="string">"org.apache.coyote.http2.Http2Protocol"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">SSLHostConfig</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Certificate</span> <span class="attr">certificateKeyFile</span>=<span class="string">"conf/localhost-rsa-key.pem"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">certificateFile</span>=<span class="string">"conf/localhost-rsa-cert.pem"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">certificateChainFile</span>=<span class="string">"conf/localhost-rsa-chain.pem"</span> <span class="attr">type</span>=<span class="string">"RSA"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">SSLHostConfig</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Connector</span>&gt;</span></span><br></pre></td></tr></table></figure></div></li><li><p>Spring Boot 在 application.properties 里配置HTTP 协议版本</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server.ssl.enabled=<span class="keyword">true</span></span><br><span class="line">server.ssl.***</span><br><span class="line">server.http2.enabled=<span class="keyword">true</span></span><br><span class="line">server.tomcat.protocol-header-https-value=https</span><br></pre></td></tr></table></figure></div></li></ul><h2 id="通过什么形式学习新技术"><a href="#通过什么形式学习新技术" class="headerlink" title="通过什么形式学习新技术"></a>通过什么形式学习新技术</h2><h2 id="还有什么要问的"><a href="#还有什么要问的" class="headerlink" title="还有什么要问的"></a>还有什么要问的</h2>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;笔经面经归纳汇总：结束问答&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="笔经面经" scheme="http://zhangchong.xin/categories/%E7%AC%94%E7%BB%8F%E9%9D%A2%E7%BB%8F/"/>
    
    
      <category term="Java" scheme="http://zhangchong.xin/tags/Java/"/>
    
      <category term="校招" scheme="http://zhangchong.xin/tags/%E6%A0%A1%E6%8B%9B/"/>
    
  </entry>
  
  <entry>
    <title>Java面试之数据结构</title>
    <link href="http://zhangchong.xin/2018/08/28/Java%20%E9%9D%A2%E8%AF%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://zhangchong.xin/2018/08/28/Java 面试之数据结构/</id>
    <published>2018-08-28T07:09:07.000Z</published>
    <updated>2019-03-12T11:23:33.027Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>笔经面经归纳汇总：数据结构</p></blockquote><a id="more"></a><h1 id="Java面试之数据结构"><a href="#Java面试之数据结构" class="headerlink" title="Java面试之数据结构"></a>Java面试之数据结构</h1><h2 id="常见数据结构"><a href="#常见数据结构" class="headerlink" title="常见数据结构"></a>常见数据结构</h2><h3 id="HashMap、Hashtable、-ConcurrentHashMap"><a href="#HashMap、Hashtable、-ConcurrentHashMap" class="headerlink" title="HashMap、Hashtable、 ConcurrentHashMap"></a>HashMap、Hashtable、 ConcurrentHashMap</h3><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><ul><li>底层实现：HashMap底层整体结构是一个数组，数组中的每个元素又是一个链表。每次添加一个对象（put）时会产生一个链表对象（Object类型），Map中的每个Entry就是数组中的一个元素（Map.Entry就是一个<code>&lt;Key,Value&gt;</code>），它具有由当前元素指向下一个元素的引用，这就构成了链表。</li><li>存储原理：当向HsahMap中添加元素的时候，首先计算Key对象的Hash值，得到数组下标，如果数组该位置为空则插入，否则遍历这个位置链表。当某个节点Key对象和Node对象均和新元素的equals时，用新元素的Value对象替换该节点的Value对象，否则插入新节点。（<strong>注意</strong>：JDK 8之后加入了红黑树）<blockquote><p>HashMap长度为2的n次幂是为了让length-1的二进制值所有位全为1，这种情况下，hash值与(table.length - 1)进行&amp;运算计算index时，其结果就等同于hashcode后几位的值，此时只要输入的hashcode本身分布均匀，Hash算法的结果就是均匀的。所以，HashMap的默认长度为16是为了降低hash碰撞的几率，同时也是一种合适的大小。</p></blockquote></li></ul><p><img src="https://raw.githubusercontent.com/chung567115/chung567115.github.io/hexo-blog/blog-img/36-1.png" alt="HashMap"></p><h4 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h4><table><thead><tr><th style="text-align:center">比较点</th><th style="text-align:center">HashMap</th><th style="text-align:center">Hashtable</th></tr></thead><tbody><tr><td style="text-align:center">实现原理</td><td style="text-align:center">见上小节</td><td style="text-align:center">和HashMap的实现原理几乎一样</td></tr><tr><td style="text-align:center">Key和Value</td><td style="text-align:center">允许Key和Value为null</td><td style="text-align:center">不允许Key和Value为null</td></tr><tr><td style="text-align:center">扩容策略</td><td style="text-align:center">2倍扩容<code>oldThr &lt;&lt; 1</code></td><td style="text-align:center">2倍+1扩容<code>(oldCapacity &lt;&lt; 1) + 1</code></td></tr><tr><td style="text-align:center">安全性</td><td style="text-align:center">线程不安全</td><td style="text-align:center">线程安全</td></tr></tbody></table><blockquote><p>Hashtable线程安全的策略实现代价很大，get/put所有相关操作都是synchronized的，在竞争激烈的并发场景中性能非常差。</p></blockquote><h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p>&emsp;&emsp;ConcurrentHashMap是Java并发包中提供的一个线程安全且高效的HashMap实现，它采用了非常精妙的<strong>分段锁</strong>策略，ConcurrentHashMap的主干是Segment数组。Segment继承于ReentrantLock，是一种可重入锁。每个Segment都是一个子哈希表，Segment里维护了一个HashEntry数组，并发环境下，对于不同Segment的数据进行操作不用考虑锁竞争。  </p><p><img src="https://raw.githubusercontent.com/chung567115/chung567115.github.io/hexo-blog/blog-img/36-2.png" alt="ConcurrentHashMap"></p><h3 id="LinkedHashMap、TreeMap、TreeSet"><a href="#LinkedHashMap、TreeMap、TreeSet" class="headerlink" title="LinkedHashMap、TreeMap、TreeSet"></a>LinkedHashMap、TreeMap、TreeSet</h3><ul><li>LinkedHashMap：顺序存取的HashMap（基于数组和双向链表实现）。</li><li>TreeMap：内部排序（基于红黑树实现）。</li><li>TreeSet：有序的Set集合（基于二叉树实现）。</li></ul><h3 id="ArrayList、LinkedList、Vector"><a href="#ArrayList、LinkedList、Vector" class="headerlink" title="ArrayList、LinkedList、Vector"></a>ArrayList、LinkedList、Vector</h3><ul><li>ArrayList：动态数组（基于数组实现）。</li><li>LinkedList：有序数组（基于双向链表实现）。</li><li>Vector：对象容器，可放入不同类的对象（基于数组实现）。</li></ul><h3 id="Collection与Collections"><a href="#Collection与Collections" class="headerlink" title="Collection与Collections"></a>Collection与Collections</h3><ul><li>Collection：集合类的上级接口，子接口主要有List、Set 、Queue等。</li><li>Collections：提供对集合进行搜索、排序、替换和线程安全化等操作的工具类。</li></ul><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="常见二叉树概念"><a href="#常见二叉树概念" class="headerlink" title="常见二叉树概念"></a>常见二叉树概念</h3><ul><li>B+树：见数据库部分<em><a href="http://zhangchong.xin/2018/07/21/Java%20%E9%9D%A2%E8%AF%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93/">点击跳转</a></em></li><li>平衡二叉树（AVL树）：各个结点左右子树深度差的绝对值不超过1。</li><li>哈夫曼树：带权路径长度最小的二叉树称为最优二叉树。哈夫曼树构造不唯一，但所有叶子结点的带权路径长度之和都是最小的。</li><li><p>红黑树：一种自平衡二叉查找树，它的性质有：</p><ol><li>节点是红色或黑色。</li><li>根节点是黑色。</li><li>每个叶子节点都是黑色的空节点（NIL节点）。</li><li>每个红色节点的两个子节点都是黑色。</li><li><p>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</p><blockquote><p>从每个叶子到根的所有路径上不能有两个连续的红色节点</p></blockquote></li></ol></li></ul><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 先序遍历算法 DLR</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Preorder</span> <span class="params">( BinTree bt )</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> ( bt ) &#123;</span><br><span class="line">visit ( bt-&gt;data );</span><br><span class="line">Preorder ( bt-&gt;lchild );</span><br><span class="line">Preorder ( bt-&gt;rchild );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 中序遍历算法 LDR</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inorder</span> <span class="params">( BinTree bt )</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> ( bt ) &#123;</span><br><span class="line">Inorder ( bt-&gt;lchild );</span><br><span class="line">visit ( bt-&gt;data );</span><br><span class="line">Inorder ( bt-&gt;rchild );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 后序遍历 LRD</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Postorder</span> <span class="params">( BinTree bt )</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> ( bt ) &#123;</span><br><span class="line">Postorder ( bt-&gt;lchild );</span><br><span class="line">Postorder ( bt-&gt;rchild );</span><br><span class="line">visit ( bt-&gt;data );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 按层次遍历。</span></span><br><span class="line"><span class="comment">/* 思路：利用一个队列，首先将根（头指针）入队列，以后若队列不空则取队头元素 p，</span></span><br><span class="line"><span class="comment">如果 p 不空，则访问之，然后将其左右子树入队列，如此循环直到队列为空。*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span> <span class="params">( BinTree bt )</span> </span>&#123;</span><br><span class="line"><span class="comment">// 队列初始化为空</span></span><br><span class="line">InitQueue ( Q );</span><br><span class="line"><span class="comment">// 根入队列</span></span><br><span class="line">EnQueue ( Q, bt );</span><br><span class="line"><span class="comment">// 队列不空则继续遍历</span></span><br><span class="line"><span class="keyword">while</span> ( ! QueueEmpty(Q) ) &#123;</span><br><span class="line">DeQueue ( Q, p );</span><br><span class="line"><span class="keyword">if</span> ( p!=<span class="literal">NULL</span> ) &#123;</span><br><span class="line">visit ( p-&gt;data );</span><br><span class="line"><span class="comment">// 左、右子树入队列</span></span><br><span class="line">EnQueue ( Q, p-&gt;lchild );</span><br><span class="line">EnQueue ( Q, p-&gt;rchild );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非递归遍历二叉树一般借助栈实现</span></span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;笔经面经归纳汇总：数据结构&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="笔经面经" scheme="http://zhangchong.xin/categories/%E7%AC%94%E7%BB%8F%E9%9D%A2%E7%BB%8F/"/>
    
    
      <category term="Java" scheme="http://zhangchong.xin/tags/Java/"/>
    
      <category term="校招" scheme="http://zhangchong.xin/tags/%E6%A0%A1%E6%8B%9B/"/>
    
  </entry>
  
  <entry>
    <title>Java面试之技术框架</title>
    <link href="http://zhangchong.xin/2018/08/28/Java%20%E9%9D%A2%E8%AF%95%E4%B9%8B%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"/>
    <id>http://zhangchong.xin/2018/08/28/Java 面试之技术框架/</id>
    <published>2018-08-28T07:08:16.000Z</published>
    <updated>2019-03-11T16:24:50.349Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>笔经面经归纳汇总：技术框架</p></blockquote><a id="more"></a><h1 id="Java面试之技术框架"><a href="#Java面试之技术框架" class="headerlink" title="Java面试之技术框架"></a>Java面试之技术框架</h1><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>&emsp;&emsp;Spring 是一种用来简化企业级应用开发的开源框架，包括Spring Framework, Spring Data, Spring Security，Spring Boot，SpringMVC等。Spring 家族最核心的概念当属 AOP 和 IoC，详解见下节。其中 Spring 优点如下：</p><ol><li>降低了组件之间的耦合性 ，实现了软件各层之间的解耦</li><li>可以使用便捷的众多服务，如事务管理，消息服务等</li><li>容器提供了AOP技术，利用它很容易实现如权限拦截，运行期监控等功能</li><li>Spring对于主流的应用框架提供了集成支持，如Hibernate、JPA等</li><li>Spring属于低侵入式设计，代码的污染极低</li><li>Spring的高度开放性，开发者可以自由选择Spring的部分或全部</li></ol><h3 id="AOP和IOC"><a href="#AOP和IOC" class="headerlink" title="AOP和IOC"></a>AOP和IOC</h3><h4 id="AOP-Aspect-Oriented-Programming，面向切面编程"><a href="#AOP-Aspect-Oriented-Programming，面向切面编程" class="headerlink" title="AOP(Aspect Oriented Programming，面向切面编程)"></a>AOP(Aspect Oriented Programming，面向切面编程)</h4><p>&emsp;&emsp;AOP简单说就是在目标方法执行前后自定义一些操作，一般都是基于代理模式来实现的，Spring支持两种代理模式，JDK原生代理和CGLib代理。AOP给程序带来良好的扩展性和封装性，可以实现业务代码与非业务代码的隔离。比如可以在不改变目标代码的前提下实现目标方法的增强：埋点业务处理、方法执行时间监控，打印日志，权限控制等等。</p><ol><li>JDK动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。只能对实现了接口的类生成代理。</li><li>CGLib动态代理是利用ASM开源包，对代理对象类的Class文件加载进来，通过修改其字节码生成子类来处理。</li></ol><ul><li>切面(Aspect)：类是对物体特征的抽象，切面就是对横切关注点的抽象。</li><li>切点(Pointcut)：对连接点进行拦截的定义。</li><li>连接点(Joinpoint)：被拦截到的点，比如方法(Spring中一般是方法)、字段、构造器。</li><li>通知(Advice)：指拦截到连接点后要执行的代码，通知分为前置、后置、异常、最终、环绕五类。</li></ul><blockquote><p>AOP：在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想</p></blockquote><h4 id="IoC-Inversion-of-Control，控制反转"><a href="#IoC-Inversion-of-Control，控制反转" class="headerlink" title="IoC(Inversion of Control，控制反转)"></a>IoC(Inversion of Control，控制反转)</h4><p>&emsp;&emsp;IOC (Inversion of Control，控制反转)：对象之间的依赖关系由容器来创建。本来对象之间的关系是由开发者自己创建和维护的，在使用Spring框架后，对象之间的关系由容器来创建和维护，将开发者做的事让容器做，这就是控制反转。<strong>BeanFactory接口是Spring Ioc容器的核心接口</strong>。<br>&emsp;&emsp;DI (Dependecy Injection，依赖注入)：我们在使用Spring容器的时候，容器通过调用set方法或者是构造器来建立对象之间的依赖关系。注入方式有设值注入、构造注入、注解注入、接口注入(<code>基本不用</code>)，设值注入直观，自然；构造注入可以在构造器中决定依赖关系的顺序。</p><blockquote><p>控制反转是目标，依赖注入是我们实现控制反转的一种手段。</p></blockquote><h3 id="SpringMVC和Struts"><a href="#SpringMVC和Struts" class="headerlink" title="SpringMVC和Struts"></a>SpringMVC和Struts</h3><p>&emsp;&emsp;SpringMVC执行流程如下：  </p><ol><li>客户端向Spring容器发起一个HTTP请求。</li><li>发起的请求被<code>前端控制器</code>(DispatcherServlet)拦截。</li><li>查询<code>处理器映射</code>（HandlerMapping）得到执行链，并请求相应的<code>处理器适配器</code>(HandlerAdapter)。</li><li>执行<code>处理器</code>(Handler)并处理请求，以ModelAndView（属性值和返回页面）的形式返回。此处Handler即平时编写的Controller。</li><li><code>前端控制器</code>查询<code>视图解析器</code>(ViewResolver)，并返回View。</li><li>成功渲染视图则返回给客户端，否则抛异常。</li></ol><table><thead><tr><th style="text-align:center">比较点</th><th style="text-align:center">SpringMVC</th><th style="text-align:center">Struts</th></tr></thead><tbody><tr><td style="text-align:center">核心控制器</td><td style="text-align:center">DispatcherServlet</td><td style="text-align:center">FilterDispatcher</td></tr><tr><td style="text-align:center">配置文件</td><td style="text-align:center">量少（AOP）</td><td style="text-align:center">量大（Interceptor机制）</td></tr><tr><td style="text-align:center">RESTful API</td><td style="text-align:center">易实现（方法级别）</td><td style="text-align:center">实现费劲（类级别）</td></tr><tr><td style="text-align:center">处理Ajax请求</td><td style="text-align:center">@ResponseBody返回响应文本</td><td style="text-align:center">拦截器集成Ajax</td></tr><tr><td style="text-align:center">性能</td><td style="text-align:center">稍快</td><td style="text-align:center">稍慢</td></tr></tbody></table><p>&emsp;&emsp;DispatcherServlet初始化流程如下：</p><ol><li>加载配置文件</li><li>扫描所有的相关类</li><li>初始化所有相关类的Class实例，并将其保存到IoC容器</li><li>自动化的依赖注入(Autowired)</li><li>初始化HandlerMapping</li></ol><h3 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h3><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>&emsp;&emsp;数据库事务是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。事务满足<strong>原子性(Atomicity)</strong>、<strong>一致性(Consistency)</strong>、<strong>隔离性(Isolation)</strong>、<strong>持久性(Durability)</strong> 四大特性。</p><blockquote><p>详见： <a href="https://blog.csdn.net/u012102104/article/details/79773362" target="_blank" rel="noopener">Java 面试之数据库</a></p></blockquote><h4 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h4><p>&emsp;&emsp;Spring通过事务管理器接口<code>PlatformTransactionManager</code>为各平台如JDBC(<code>DataSourceTransactionManager</code>)、Hibernate(<code>HibernateTransactionManager</code>、<code>JpaTransactionManager</code>)等都提供了对应的事务管理器。  </p><h4 id="事务的传播特性"><a href="#事务的传播特性" class="headerlink" title="事务的传播特性"></a>事务的传播特性</h4><p>&emsp;&emsp;当事务方法被另一个事务方法调用时，必须指定事务应该如何传播，根据如下代码中方法 A 有无事务，Spring定义了7种传播行为（默认为REQUIRED）：<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A</span><span class="params">()</span></span>&#123;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="meta">@Transactional</span>  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">B</span><span class="params">()</span></span>&#123;  </span><br><span class="line">   A();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p><table><thead><tr><th style="text-align:center">传播行为(简写)</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center"><strong>REQUIRED</strong></td><td style="text-align:center">如果没有，就开启一个事务；如果有，就加入当前事务（方法A加入到方法B）</td></tr><tr><td style="text-align:center">REQUIRES_NEW</td><td style="text-align:center">如果没有，就开启一个事务；如果有，就将当前事务挂起</td></tr><tr><td style="text-align:center">NESTED</td><td style="text-align:center">如果没有，就开启一个事务；如果有，就在当前事务中嵌套其他事务（主事务提交或回滚，子事务也会提交或回滚）</td></tr><tr><td style="text-align:center">SUPPORTS</td><td style="text-align:center">如果没有，就以非事务方式执行；如果有，就使用当前事务</td></tr><tr><td style="text-align:center">NOT_SUPPORTED</td><td style="text-align:center">如果没有，就以非事务方式执行；如果有，就将当前事务挂起</td></tr><tr><td style="text-align:center">NEVER</td><td style="text-align:center">如果没有，就以非事务方式执行；如果有，就抛出异常</td></tr><tr><td style="text-align:center">MANDATORY</td><td style="text-align:center">如果没有，就抛出异常；如果有，就使用当前事务</td></tr></tbody></table><h3 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h3><p>&emsp;&emsp;Spring Boot来自于 Spring 大家族，是一套全新的框架，它默认帮我们进行了很多配置，集成了大量常用的第三方库（例如 Jackson、JDBC、MongoDB、Redis、Mail 等），这些第三方库几乎都可以开箱即用。Spring Boot可以帮助我们快速搭建一个项目，从而让开发者能够更加专注于业务逻辑。  </p><h3 id="Spring扩展"><a href="#Spring扩展" class="headerlink" title="Spring扩展"></a>Spring扩展</h3><ul><li>实现BeanPostProcess接口在Bean生成前后进行操作。</li><li>实现BeanFactoryPostProcessor接口配置Bean元属性。</li><li>实现FactoryBean接口定制个性化的Bean。</li></ul><h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><p>&emsp;&emsp;MyBatis是一款优秀的持久层框架，它几乎避免了所有的JDBC代码和手动设置参数以及获取结果集，它可以使用XML或注解来将接口和POJO映射成数据库中的记录。<br>&emsp;&emsp;MyBatis与Spring集成的时候Spring提供了全局唯一的SqlSessionTemplate，SqlSessionTemplate 实现了SqlSession接口，那么如何保证多个线程调用同一个dao时拿到的SqlSession不会错乱呢？这个时候就用到了ThreadLocal，SqlSessionUtils.getSqlSession()会首先查看当前线程资源map有无SqlSession，有则返回无则新建然后返回，这样就能保证一条业务始终用的是同一个数据库连接，也就能正确处理数据库事务。</p><h3 id="MyBatis和Hibernate"><a href="#MyBatis和Hibernate" class="headerlink" title="MyBatis和Hibernate"></a>MyBatis和Hibernate</h3><table><thead><tr><th style="text-align:center">比较点</th><th style="text-align:center">MyBatis</th><th style="text-align:center">Hibernate</th></tr></thead><tbody><tr><td style="text-align:center">特点</td><td style="text-align:center">半自动(手写SQL)</td><td style="text-align:center">全自动(根据映射生成SQL)</td></tr><tr><td style="text-align:center">SQL直接优化</td><td style="text-align:center">方便</td><td style="text-align:center">复杂</td></tr><tr><td style="text-align:center">数据库移植性</td><td style="text-align:center">弱</td><td style="text-align:center">强</td></tr><tr><td style="text-align:center">缓存机制</td><td style="text-align:center">欠缺</td><td style="text-align:center">更优</td></tr><tr><td style="text-align:center">日志系统</td><td style="text-align:center">欠缺</td><td style="text-align:center">完整</td></tr></tbody></table><h3 id="Statement和PreparedStatement的区别"><a href="#Statement和PreparedStatement的区别" class="headerlink" title="Statement和PreparedStatement的区别"></a>Statement和PreparedStatement的区别</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***PreparedStatement extends Statement***/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Statement用法</span></span><br><span class="line">sql1 = <span class="string">"select * from tbl_user where username='"</span> + u + <span class="string">"' and password='"</span> + p + <span class="string">"'"</span>;</span><br><span class="line">statement = conn.createStatement();  </span><br><span class="line">result1 = statement.executeQuery(sql1);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//PrepareStatement用法</span></span><br><span class="line">sql2 = <span class="string">"select * from tbl_user where username=? and password=?"</span>;  </span><br><span class="line">prepareStatement = conn.prepareStatement(sql2);  </span><br><span class="line">pstmt.setString(<span class="number">1</span>, u);  </span><br><span class="line">pstmt.setString(<span class="number">2</span>, p);  </span><br><span class="line">result2 = prepareStatement.executeQuery();</span><br></pre></td></tr></table></figure></div><table><thead><tr><th style="text-align:center">比较点</th><th style="text-align:center">Statement</th><th style="text-align:center">PreparedStatement</th></tr></thead><tbody><tr><td style="text-align:center">用途</td><td style="text-align:center">执行静态SQL语句并返回结果</td><td style="text-align:center">执行已预编译SQL语句并返回结果</td></tr><tr><td style="text-align:center">可读性</td><td style="text-align:center">低(字符串拼接)</td><td style="text-align:center">高(Set方法设值)</td></tr><tr><td style="text-align:center">效率</td><td style="text-align:center">低(字符串拼接)</td><td style="text-align:center">高(占位符)</td></tr><tr><td style="text-align:center">安全性</td><td style="text-align:center">低(SQL注入)</td><td style="text-align:center">高</td></tr></tbody></table><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><ol><li>消息队列中间件是分布式系统中重要的组件，主要主要解决应用耦合、异步消息、流量削锋等问题，具有异步性、可靠性（存储到本地硬盘）、松耦合、分布式的特性。  <ul><li>主要特点是异步处理</li><li>主要目的是减少请求响应时间、解耦</li><li>主要使用场景是将比较耗时且不需同步返回结果的操作当做消息存入队列</li></ul></li><li>流量削峰的一种解决方案  <ul><li>MQ推送模式改为定时或者批量拉取模式</li><li>消息接收方实现批量处理等方式</li></ul></li><li>RabbitMQ<ul><li>RabbitMQ 是一个由 ErLang 开发的AMQP的开源实现。</li><li>交换机（Exchange）的功能主要是接收消息并且转发到绑定的队列，交换机不存储消息，<strong>交换机本质是一张路由查询表</strong>。<ul><li>Direct：绑定时设定一个路由键，消息的路由键匹配才会被投送到队列中。</li><li>Topic：根据模糊匹配转发消息（最灵活）。</li><li>Headers：设置头部参数类型的交换机。</li><li>Fanout：转发消息到所有绑定队列，消息广播的模式。</li></ul></li></ul></li></ol><blockquote><p>路由键（routing_key）在消息中，而绑定键（binding_key）作用于交换机和队列之间。当消息中的路由键和绑定键对应上的时候，交换机就知道将该消息存入哪个队列。</p></blockquote><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><ul><li>分布式：一个业务分拆多个子业务，部署在不同的服务器上（厨师和配菜师的关系）</li><li>集群：同一个业务，部署在多个服务器上（两个厨师的关系）</li></ul><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>&emsp;&emsp;微服务架构风格是一种<strong>使用一套小服务来开发单个应用</strong>的方式，每个服务运行在自己的进程中，并使用轻量级机制通信（通常是<code>HTTP API</code>），这些服务能够通过自动化部署机制来独立部署、可以使用不同的编程语言实现、可以使用不同的数据存储技术，并保持最低限度的集中式管理。<br>&emsp;&emsp;时下热门的微服务开发框架有：<a href="http://projects.spring.io/spring-cloud" target="_blank" rel="noopener">Spring Cloud</a>、<a href="http://dubbo.io" target="_blank" rel="noopener">Dubbo</a></p><h2 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h2><p>&emsp;&emsp;<strong>URL定位资源，HTTP动词描述操作</strong>    </p><ul><li>GET：读取资源</li><li>POST：创建资源</li><li>PUT：更新资源</li><li>DELETE：删除资源</li></ul><blockquote><p>使用PUT方式更新时，必须发送资源所有的属性</p></blockquote><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><ul><li><p>正向代理：隐藏真实的请求客户端，服务端不知道真实的客户端是谁，正向代理服务器会代替客户端向服务器发送请求。<strong>正向代理代理的对象是客户端</strong>。</p></li><li><p>反向代理：隐藏真实的响应服务端，客户端不知道真实的服务端是谁，反向代理服务器会把请求转发到真实的服务器。<strong>反向代理代理的对象是服务端</strong>。</p></li></ul><blockquote><p>10086总机就是一种反向代理，客户不知道真正提供服务人的是谁。</p></blockquote><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><ul><li><strong>四层负载均衡</strong>：工作在OSI模型的<strong>传输层</strong>，它在接收到客户端的流量以后通过修改数据包的地址信息将流量转发到应用服务器，因此四层负载均衡的主要工作就是<strong>转发</strong>。</li><li><strong>七层负载均衡</strong>：工作在OSI模型的<strong>应用层</strong>，七层负载均衡在接到客户端的流量以后，还需要一个完整的TCP/IP协议栈与客户端建立一条完整的连接，并将应用层的请求流量解析出来，再按照调度算法选择一个应用服务器，并与应用服务器建立另外一条连接将请求发送过去，因此七层负载均衡的主要工作就是<strong>代理</strong>。</li></ul><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h3><ol><li>单一职责原则：一个类只负责一个功能领域中的相应职责。</li><li>开闭原则：一个软件实体应当对扩展开放，对修改关闭。</li><li>里氏替换原则：所有引用父类的地方必须能透明地使用其子类的对象。</li><li>依赖倒置原则：抽象不应该依赖于细节，细节应当依赖于抽象。(要针对接口编程，而不是针对实现编程)。</li><li>接口隔离原则：使用多个专门的接口，而不使用单一的总接口。</li><li>迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用。</li></ol><h3 id="单例、工厂、观察者、适配器、责任链"><a href="#单例、工厂、观察者、适配器、责任链" class="headerlink" title="单例、工厂、观察者、适配器、责任链"></a>单例、工厂、观察者、适配器、责任链</h3><ul><li>单例模式：一个类负责创建自己的对象，同时确保只有单个对象被创建，并提供一种访问其唯一对象的方式。</li><li>工厂模式：在创建对象时不暴露创建逻辑，并通过使用一个共同的接口来指向新创建的对象。</li><li>代理模式：一个类代表另一个类的功能，为其他对象提供一种代理以控制对这个对象的访问。</li><li>模板模式：一个抽象类公开定义了方法，它的子类可以按需要重写方法，但以抽象类中定义的模板调用。</li><li>策略模式：定义一系列的算法，把它们一个个封装起来,，并且使它们可相互替换。</li><li>过滤器模式：允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。</li><li>适配器模式：将一个类的接口转换成另一个接口，使原本由于接口不兼容而不能一起工作的类可以一起工作。</li><li>观察者模式：定义对象间的依赖关系，当一个对象的状态改变时，所有依赖于它的对象都被通知并自动更新。</li><li>责任链模式：为请求创建了一个接收者对象的链，沿着这条链传递请求，直到有对象处理它为止。<blockquote><p>设计模式详见小博系列博客：<a href="https://blog.csdn.net/u012102104/article/details/85328253" target="_blank" rel="noopener">代码详解设计模式汇总</a></p></blockquote></li></ul><h3 id="写出生产者消费者模式"><a href="#写出生产者消费者模式" class="headerlink" title="写出生产者消费者模式"></a>写出生产者消费者模式</h3><p>&emsp;&emsp;生产者生产数据到缓冲区中，消费者从缓冲区中取数据。如果缓冲区已经满了，则生产者线程阻塞；如果缓冲区为空，那么消费者线程阻塞。<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerAndConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> BlockingQueue resourceQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;Resource&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Producer p = <span class="keyword">new</span> Producer(); <span class="comment">//生产者</span></span><br><span class="line">        Consumer c1 = <span class="keyword">new</span> Consumer(); <span class="comment">//消费者1</span></span><br><span class="line">        Consumer c2 = <span class="keyword">new</span> Consumer(); <span class="comment">//消费者2</span></span><br><span class="line">        Consumer c3 = <span class="keyword">new</span> Consumer(); <span class="comment">//消费者3</span></span><br><span class="line">        p.start();</span><br><span class="line">        c1.start();</span><br><span class="line">        c2.start();</span><br><span class="line">        c3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Resource</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Resource resource = <span class="keyword">new</span> Resource(p++);</span><br><span class="line">                System.out.println(<span class="string">"生产资源"</span> + resource.id);</span><br><span class="line">                ProducerAndConsumer.resourceQueue.put(resource);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"消费资源"</span> + </span><br><span class="line">                ((Resource) ProducerAndConsumer.resourceQueue.take()).id);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p><h2 id="高内聚、低耦合"><a href="#高内聚、低耦合" class="headerlink" title="高内聚、低耦合"></a>高内聚、低耦合</h2><ul><li>耦合性：也称块间联系。指软件各模块之间相互联系紧密程度的一种度量。模块之间联系越紧密，则其耦合性就越强。模块间耦合高低取决于模块间接口的复杂性、调用的方式及传递的信息。</li><li>内聚性：也称块内联系。指软件模块内部各元素彼此结合紧密程度的一种度量。模块内各元素（语名之间、程序段之间）联系越紧密，则其内聚性就越高。</li></ul><blockquote><p>高内聚、低耦合的系统具有更好的重用性，维护性，扩展性，可以更高效的完成系统的维护开发，持续的支持业务的发展，而不会成为业务发展的障碍</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;笔经面经归纳汇总：技术框架&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="笔经面经" scheme="http://zhangchong.xin/categories/%E7%AC%94%E7%BB%8F%E9%9D%A2%E7%BB%8F/"/>
    
    
      <category term="Java" scheme="http://zhangchong.xin/tags/Java/"/>
    
      <category term="校招" scheme="http://zhangchong.xin/tags/%E6%A0%A1%E6%8B%9B/"/>
    
  </entry>
  
  <entry>
    <title>Java面试之语言基础</title>
    <link href="http://zhangchong.xin/2018/08/28/Java%20%E9%9D%A2%E8%AF%95%E4%B9%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    <id>http://zhangchong.xin/2018/08/28/Java 面试之语言基础/</id>
    <published>2018-08-28T07:07:49.000Z</published>
    <updated>2019-03-11T16:25:01.307Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>笔经面经归纳汇总：Java基础</p></blockquote><a id="more"></a><h1 id="Java面试之语言基础"><a href="#Java面试之语言基础" class="headerlink" title="Java面试之语言基础"></a>Java面试之语言基础</h1><h2 id="Java八种基本数据类型"><a href="#Java八种基本数据类型" class="headerlink" title="Java八种基本数据类型"></a>Java八种基本数据类型</h2><table><thead><tr><th style="text-align:center">类 型</th><th style="text-align:center">大小</th><th style="text-align:center">封 装 类</th></tr></thead><tbody><tr><td style="text-align:center">byte</td><td style="text-align:center">1字节</td><td style="text-align:center">Byte</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">2字节</td><td style="text-align:center">Short</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">4字节</td><td style="text-align:center">Integer</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">8字节</td><td style="text-align:center">Long</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">4字节</td><td style="text-align:center">Float</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">8字节</td><td style="text-align:center">Double</td></tr><tr><td style="text-align:center">char</td><td style="text-align:center">2字节</td><td style="text-align:center">Character</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">–</td><td style="text-align:center">Boolean</td></tr></tbody></table><h2 id="Java面向对象（四个基本特性）"><a href="#Java面向对象（四个基本特性）" class="headerlink" title="Java面向对象（四个基本特性）"></a>Java面向对象（四个基本特性）</h2><ol><li><strong>封装</strong>：将客观事物包装成类，隐藏具体实现，提供操作接口。</li><li><strong>继承</strong>：子类获得父类的属性和行为(<code>extends</code>)。</li><li><strong>多态</strong>：同一行为多种表现形式。<ul><li>重写<code>Override</code></li><li>接口的不同实现<code>implements</code></li><li>抽象类和抽象方法<code>abstract</code></li></ul></li><li><strong>抽象</strong>：用代码描述客观事物。包括数据抽象(属性)和过程抽象(行为)。</li></ol><h2 id="Java与C-对比"><a href="#Java与C-对比" class="headerlink" title="Java与C++对比"></a>Java与C++对比</h2><table><thead><tr><th style="text-align:center">比较点</th><th style="text-align:center">Java</th><th style="text-align:center">C++</th></tr></thead><tbody><tr><td style="text-align:center">面向对象思想</td><td style="text-align:center">完全对象化</td><td style="text-align:center">可采用非面向对象(兼容C)</td></tr><tr><td style="text-align:center">内存管理机制</td><td style="text-align:center">Java自身管理</td><td style="text-align:center">程序员管理</td></tr><tr><td style="text-align:center">异常机制</td><td style="text-align:center">完善</td><td style="text-align:center">欠缺</td></tr><tr><td style="text-align:center">第三方库</td><td style="text-align:center">丰富(Log、JUnit等等)</td><td style="text-align:center">较少(STL)</td></tr><tr><td style="text-align:center">执行效率</td><td style="text-align:center">慢</td><td style="text-align:center">快</td></tr><tr><td style="text-align:center">操控底层</td><td style="text-align:center">麻烦</td><td style="text-align:center">方便</td></tr></tbody></table><h2 id="Java-8新特性"><a href="#Java-8新特性" class="headerlink" title="Java 8新特性"></a>Java 8新特性</h2><ul><li><strong>默认方法</strong>：在接口里面有了一个实现的方法</li><li>Lambda 表达式：Lambda允许把函数作为一个方法的参数</li><li>Stream API：把真正的函数式编程风格引入到Java中</li><li>Date Time API：加强对日期与时间的处理</li><li>Optional 类：Optional 类已成为 Java 8类库的一部分，用来解决空指针异常</li><li>方法引用：可以直接引用已有Java类或对象的方法或构造器</li><li>新编译工具：Nashorn引擎（一个新的JavaScript引擎）、 类依赖分析器</li></ul><h2 id="Java反射机制"><a href="#Java反射机制" class="headerlink" title="Java反射机制"></a>Java反射机制</h2><p>&emsp;&emsp;在运行状态中，对于任意一个类，都能够知道其所有属性和方法；对于任意一个对象，都能够调用其任意方法和属性。这种动态获取信息及动态调用对象方法的功能称为Java语言的反射机制。Java反射API如下：  </p><ul><li>Class：反射的核心类。</li><li>Field：类的成员变量。 </li><li>Method：类的成员方法。 </li><li>Constructor：类的构造方法。</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**获取Class对象的三种方式**/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 调用某个对象的getClass()方法</span></span><br><span class="line">Class clazz = person.getClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 调用某个类的class属性</span></span><br><span class="line">Class clazz = Person.class;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 使用Class类的forName()静态方法</span></span><br><span class="line">Class clazz = Class.forName(<span class="string">"Person"</span>);</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;反射机制主要提供了以下功能：</p><ol><li>在运行时判断任意一个对象所属的类。</li><li>在运行时构造任意一个类的对象。</li><li>在运行时判断任意一个类所具有的成员变量和方法。</li><li>在运行时调用任意一个对象的方法。</li><li>生成动态代理。</li></ol><h2 id="Java异常机制"><a href="#Java异常机制" class="headerlink" title="Java异常机制"></a>Java异常机制</h2><h3 id="Error与Excption包结构"><a href="#Error与Excption包结构" class="headerlink" title="Error与Excption包结构"></a>Error与Excption包结构</h3><ol><li>Error：程序无法处理的错误，继承自Throwable。</li><li><p>Exception：程序可以处理的异常，继承自Throwable。</p><ol><li>Checked Exception：<strong>受检异常，需要强制catch</strong>，是Exception的子类。</li><li><p>Unchecked Exception：<strong>不受检异常，无需强制catch</strong>，是RuntimeException的子类。</p><blockquote><p>例如<code>list.size()</code>语句，若list为null，则会出现<code>NullPointerException</code>(Unchecked Exception)</p></blockquote></li></ol></li></ol><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ex <span class="keyword">instanceof</span> RuntimeException)&#123;</span><br><span class="line">    <span class="comment">// ex is unchecked exception</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> Exception)&#123;</span><br><span class="line">    <span class="comment">// ex is checked exception</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ex is a error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img src="/34-1.png" alt="Throwable体系"></p><h2 id="各种比较"><a href="#各种比较" class="headerlink" title="各种比较"></a>各种比较</h2><h3 id="Override和Overload的区别"><a href="#Override和Overload的区别" class="headerlink" title="Override和Overload的区别"></a>Override和Overload的区别</h3><table><thead><tr><th style="text-align:center">比较点</th><th style="text-align:center">Override</th><th style="text-align:center">Overload</th></tr></thead><tbody><tr><td style="text-align:center">中文</td><td style="text-align:center">重写</td><td style="text-align:center">重载</td></tr><tr><td style="text-align:center">方法名</td><td style="text-align:center">相同</td><td style="text-align:center">相同</td></tr><tr><td style="text-align:center">形参</td><td style="text-align:center">相同</td><td style="text-align:center">不同</td></tr><tr><td style="text-align:center">返回类型</td><td style="text-align:center">相同</td><td style="text-align:center">可同可不同</td></tr></tbody></table><blockquote><p>Override 典型例子：接口方法的重写<br>Overload 典型例子：构造方法的重载</p></blockquote><h3 id="Interface与abstract类的区别"><a href="#Interface与abstract类的区别" class="headerlink" title="Interface与abstract类的区别"></a>Interface与abstract类的区别</h3><table><thead><tr><th style="text-align:center">比较点</th><th style="text-align:center">Interface</th><th style="text-align:center">abstract类</th></tr></thead><tbody><tr><td style="text-align:center">中文</td><td style="text-align:center">接口</td><td style="text-align:center">抽象类</td></tr><tr><td style="text-align:center">能否实例化</td><td style="text-align:center">不能</td><td style="text-align:center">不能</td></tr><tr><td style="text-align:center">方法能否实现</td><td style="text-align:center">Java 8 可以</td><td style="text-align:center">可以</td></tr><tr><td style="text-align:center">一个类可以</td><td style="text-align:center"><code>implements</code>多个</td><td style="text-align:center"><code>extends</code>一个</td></tr></tbody></table><h3 id="equals-与-的区别"><a href="#equals-与-的区别" class="headerlink" title="equals()与==的区别"></a>equals()与==的区别</h3><p>&emsp;&emsp;<code>equals()</code>用于比较对象(内容)，<code>==</code>常用于比较原生类型(地址)。简单的说，<code>==</code>比较两个人的DNA，<code>equals()</code>一般用来比较两个人身高体重等等，可自定义。<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">10</span>;</span><br><span class="line">String str1 = <span class="string">"abc"</span>;</span><br><span class="line">String str2 = <span class="string">"abc"</span>;</span><br><span class="line">String str3 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">String str4 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// == 比较两个(基本数据类型)地址值</span></span><br><span class="line">System.out.println(x == y); <span class="comment">// true</span></span><br><span class="line">System.out.println(str1 == str2); <span class="comment">// true</span></span><br><span class="line">System.out.println(str3 == str4); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// String重写的equals()比较两个对象内容</span></span><br><span class="line">System.out.println(str1.equals(str2)); <span class="comment">// true</span></span><br><span class="line">System.out.println(str3.equals(str4)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div></p><blockquote><p>要注意Object类中<code>equals()</code>即为<code>==</code>，<code>equals()</code>是可以重写(<code>Override</code>)的。  </p></blockquote><h3 id="String、StringBuffer、StringBuilder"><a href="#String、StringBuffer、StringBuilder" class="headerlink" title="String、StringBuffer、StringBuilder"></a>String、StringBuffer、StringBuilder</h3><table><thead><tr><th style="text-align:center">比较点</th><th style="text-align:center">String</th><th style="text-align:center">StringBuffer</th><th style="text-align:center">StringBuilder</th></tr></thead><tbody><tr><td style="text-align:center">底层实现</td><td style="text-align:center">final char value[]</td><td style="text-align:center">char[] value</td><td style="text-align:center">char[] value</td></tr><tr><td style="text-align:center">可变性(参考底层)</td><td style="text-align:center">不可变</td><td style="text-align:center">可变</td><td style="text-align:center">可变</td></tr><tr><td style="text-align:center">修改时</td><td style="text-align:center"><strong>不会</strong>改变自身</td><td style="text-align:center"><strong>会</strong>改变自身</td><td style="text-align:center"><strong>会</strong>改变自身</td></tr><tr><td style="text-align:center">安全性</td><td style="text-align:center">线程安全</td><td style="text-align:center">线程安全</td><td style="text-align:center">非线程安全</td></tr><tr><td style="text-align:center">使用场景</td><td style="text-align:center">少量数据</td><td style="text-align:center">多线程大量数据</td><td style="text-align:center">单线程大量数据</td></tr></tbody></table><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"abc"</span>; <span class="comment">// str只是一个String对象的引用</span></span><br><span class="line">str = <span class="string">"xyz"</span>; <span class="comment">// 创建了新对象"xyz"，而引用str重新指向新对象</span></span><br></pre></td></tr></table></figure></div><h3 id="强弱软虚四种引用"><a href="#强弱软虚四种引用" class="headerlink" title="强弱软虚四种引用"></a>强弱软虚四种引用</h3><table><thead><tr><th style="text-align:center">比较点</th><th style="text-align:center">强引用</th><th style="text-align:center">软引用</th><th style="text-align:center">弱引用</th><th style="text-align:center">虚引用</th></tr></thead><tbody><tr><td style="text-align:center">特性</td><td style="text-align:center">不会被回收</td><td style="text-align:center">内存足则不回收，内存不足则回收</td><td style="text-align:center">一旦发现便回收</td><td style="text-align:center">必须和引用队列联合使用</td></tr><tr><td style="text-align:center">使用场景</td><td style="text-align:center">平时工作接触的最多(<code>new</code>)</td><td style="text-align:center">可用来实现内存敏感的高速缓存</td><td style="text-align:center">常用于Map数据结构中，引用占用内存空间较大的对象</td><td style="text-align:center">跟踪对象被回收的活动</td></tr></tbody></table><h3 id="comparable接口和comparator接口"><a href="#comparable接口和comparator接口" class="headerlink" title="comparable接口和comparator接口"></a>comparable接口和comparator接口</h3><ul><li>Comparable：在集合内部实现排序的接口，位于java.lang包。</li><li>Comparator：在集合外部实现排序的比较器接口，位于java.util包。</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用字符串的比较</span></span><br><span class="line">        <span class="keyword">int</span> i = name.compareTo(((Person) o).name); </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123; <span class="comment">// 如果名字一样,比较年龄, 返回比较年龄结果</span></span><br><span class="line">            <span class="keyword">return</span> age - ((Person) o).age;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i; <span class="comment">// 名字不一样, 返回比较名字的结果.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用Collections.sort(personList)即可排序</span></span><br></pre></td></tr></table></figure></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 使用字符串的比较</span></span><br><span class="line">            <span class="keyword">int</span> i = ((Person) o1).name.compareTo(((Person) o2).name); </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123; <span class="comment">// 如果名字一样,比较年龄,返回比较年龄结果</span></span><br><span class="line">                <span class="keyword">return</span> ((Person) o1).age - ((Person) o2).age;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> i; <span class="comment">// 名字不一样, 返回比较名字的结果.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用Collections.sort(list, new Person.PersonComparator())即可排序</span></span><br></pre></td></tr></table></figure></div><blockquote><p>Arrays内使用双轴快排(DualPivotQuicksort)，两个中心点三段数据。</p></blockquote><h3 id="IO，BIO，NIO，AIO"><a href="#IO，BIO，NIO，AIO" class="headerlink" title="IO，BIO，NIO，AIO"></a>IO，BIO，NIO，AIO</h3><p>&emsp;&emsp;Java中IO是以流为基础进行输入输出的，在网络编程中，接触到最多的就是利用Socket进行网络通信开发，主要有BIO、NIO、AIO三种实现方式。  </p><table><thead><tr><th style="text-align:center">比较点</th><th style="text-align:center">BIO</th><th style="text-align:center">NIO</th><th style="text-align:center">AIO</th></tr></thead><tbody><tr><td style="text-align:center">中文</td><td style="text-align:center">阻塞IO</td><td style="text-align:center">非阻塞IO</td><td style="text-align:center">异步IO</td></tr><tr><td style="text-align:center">版本</td><td style="text-align:center">–</td><td style="text-align:center">JDK 1.4提出</td><td style="text-align:center">JDK 1.7 提出</td></tr><tr><td style="text-align:center">描述</td><td style="text-align:center">服务端每次都需要创建一个线程来建立连接并处理消息。若建立连接、读写数据时发生阻碍，线程会阻塞。并发情况下，N个连接需要N个线程来处理。</td><td style="text-align:center">使用一个线程来管理所有的Socket 通道，也就是基于Selector机制，查询到事件时(连接、读写)，转发给不同的处理线程(Handler)。</td><td style="text-align:center">在进行读写操作时，只需要调用相应的read/write方法，并传入CompletionHandler(动作完成处理器)，在动作完成后会调用CompletionHandler。</td></tr></tbody></table><h2 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h2><p>&emsp;&emsp;序列化即把对象转换为字节序列；反序列化即把字节序列恢复为对象。其使用场景大致有如下几种：  </p><ul><li>把内存中的对象状态保存到文件或者数据库中。</li><li>用套接字在网络上传送对象。</li><li>通过RMI传输对象。</li></ul><blockquote><p>JVM会把字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化。</p></blockquote><h2 id="哪些情况会导致OOM或SOF，怎么解决"><a href="#哪些情况会导致OOM或SOF，怎么解决" class="headerlink" title="哪些情况会导致OOM或SOF，怎么解决"></a>哪些情况会导致OOM或SOF，怎么解决</h2><h3 id="OutOfMemory-OOM"><a href="#OutOfMemory-OOM" class="headerlink" title="OutOfMemory(OOM)"></a>OutOfMemory(OOM)</h3><ul><li>Java堆溢出：一般由于内存泄露或者堆的大小设置不当引起。可以通过虚拟机参数<code>-Xms</code>、<code>-Xmx</code>等设置堆大小。</li><li>方法区溢出：包括运行时常量池溢出，一般由于大量动态生成的Class导致。可以通过<code>-XX:PermSize</code>和<code>-XX:MaxPermSize</code>限制方法区的大小。<blockquote><p>使用JConsole生成Heap Dump文件，然后使用MAT分析排查</p></blockquote></li></ul><h3 id="StackOverflow-SOF"><a href="#StackOverflow-SOF" class="headerlink" title="StackOverflow(SOF)"></a>StackOverflow(SOF)</h3><ul><li>Java虚拟机栈和本地方法栈内存溢出：一般是由于程序中存在死循环或者深度递归调用造成的，栈设置太小也会出现此种溢出。可以通过虚拟机参数<code>-Xss</code>来设置栈大小。</li></ul><h2 id="JNI的使用"><a href="#JNI的使用" class="headerlink" title="JNI的使用"></a>JNI的使用</h2><p>&emsp;&emsp;JNI (Java Native Interface)允许Java代码和其他语言代码(主要是C和C++)进行交互。  </p><ol><li>定义本地native方法</li><li>用javah命令生成.h头文件，拷贝至jni目录</li><li>在jni目录中编写.c文件</li><li>在jni目录中创建Android.mk文件，声明所引用的.c文件和生成的函数库名</li><li>创建Application.mk文件，声明支持的平台(armeabi、armeabi-v7a、x86)</li><li>使用ndk工具编译生成.so成动态链接库文件</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;笔经面经归纳汇总：Java基础&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="笔经面经" scheme="http://zhangchong.xin/categories/%E7%AC%94%E7%BB%8F%E9%9D%A2%E7%BB%8F/"/>
    
    
      <category term="Java" scheme="http://zhangchong.xin/tags/Java/"/>
    
      <category term="校招" scheme="http://zhangchong.xin/tags/%E6%A0%A1%E6%8B%9B/"/>
    
  </entry>
  
  <entry>
    <title>杭州(准)独角兽名单</title>
    <link href="http://zhangchong.xin/2018/08/05/%E6%9D%AD%E5%B7%9E(%E5%87%86)%E7%8B%AC%E8%A7%92%E5%85%BD%E5%90%8D%E5%8D%95/"/>
    <id>http://zhangchong.xin/2018/08/05/杭州(准)独角兽名单/</id>
    <published>2018-08-05T04:10:28.000Z</published>
    <updated>2019-03-12T11:27:44.010Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>茫茫大海，如何选择心仪的公司，啊哈哈</p></blockquote><a id="more"></a><h2 id="创投协会和微链发布的-准-独角兽名单"><a href="#创投协会和微链发布的-准-独角兽名单" class="headerlink" title="创投协会和微链发布的(准)独角兽名单"></a>创投协会和微链发布的(准)独角兽名单</h2><hr><p><img src="https://raw.githubusercontent.com/chung567115/chung567115.github.io/hexo-blog/blog-img/33-1.png" alt="杭州独角兽"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;茫茫大海，如何选择心仪的公司，啊哈哈&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="业余知识" scheme="http://zhangchong.xin/categories/%E4%B8%9A%E4%BD%99%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="独角兽" scheme="http://zhangchong.xin/tags/%E7%8B%AC%E8%A7%92%E5%85%BD/"/>
    
  </entry>
  
  <entry>
    <title>Java面试之数据库</title>
    <link href="http://zhangchong.xin/2018/07/21/Java%20%E9%9D%A2%E8%AF%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://zhangchong.xin/2018/07/21/Java 面试之数据库/</id>
    <published>2018-07-21T03:13:24.000Z</published>
    <updated>2019-03-12T11:22:07.396Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>笔经面经归纳汇总：数据库</p></blockquote><a id="more"></a><h1 id="Java面试之数据库"><a href="#Java面试之数据库" class="headerlink" title="Java面试之数据库"></a>Java面试之数据库</h1><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h3><p>&emsp;&emsp;数据库事务是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。事务满足以下四大特性：  </p><ol><li><strong>原子性（Atomicity）</strong>：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚到事务开始前的状态。</li><li><strong>一致性（Consistency）</strong>：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。</li><li><strong>隔离性（Isolation）</strong>：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。</li><li><strong>持久性（Durability）</strong>：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ol><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>&emsp;&emsp;数据读的三类问题：</p><table><thead><tr><th style="text-align:center">问题</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">脏读</td><td style="text-align:center">事务 A 读取了事务 B 未提交的数据（发现读到的数据是脏数据）</td></tr><tr><td style="text-align:center">不可重复读</td><td style="text-align:center">事务 A 读取了事务 B 已提交的更改数据（发现与前一次读的不一致）</td></tr><tr><td style="text-align:center">幻读</td><td style="text-align:center">事务 A 读取了事务 B 已提交的新增数据（发现之前没有这条数据的）</td></tr></tbody></table><p>&emsp;&emsp;事务的四种隔离级别见下表，MySQL默认为<strong>REPEATABLE_READ</strong>：  </p><table><thead><tr><th style="text-align:center">隔离级别(简写)</th><th style="text-align:center">含义</th><th style="text-align:center">隐患</th></tr></thead><tbody><tr><td style="text-align:center">READ_UNCOMMITTED</td><td style="text-align:center">允许读未提交</td><td style="text-align:center">脏读、不可重复读、幻读</td></tr><tr><td style="text-align:center">READ_COMMITTED</td><td style="text-align:center">允许读已提交</td><td style="text-align:center">不可重复读、幻读</td></tr><tr><td style="text-align:center">REPEATABLE_READ</td><td style="text-align:center">允许重复读</td><td style="text-align:center">幻读</td></tr><tr><td style="text-align:center">SERIALIZABLE</td><td style="text-align:center">序列化读</td><td style="text-align:center">–</td></tr></tbody></table><h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><table><thead><tr><th style="text-align:center">比较点</th><th style="text-align:center">InnoDB</th><th style="text-align:center">MyISAM</th></tr></thead><tbody><tr><td style="text-align:center">事务</td><td style="text-align:center">支持</td><td style="text-align:center">不支持</td></tr><tr><td style="text-align:center">外键</td><td style="text-align:center">支持</td><td style="text-align:center">不支持</td></tr><tr><td style="text-align:center">锁</td><td style="text-align:center">行锁</td><td style="text-align:center">表锁</td></tr><tr><td style="text-align:center">索引</td><td style="text-align:center">聚集索引（数据和索引捆绑）</td><td style="text-align:center">非聚集索引（数据和索引分离)</td></tr><tr><td style="text-align:center">FullText索引</td><td style="text-align:center">不支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">跨平台</td><td style="text-align:center">可直接拷贝</td><td style="text-align:center">难直接拷贝</td></tr><tr><td style="text-align:center">表格压缩</td><td style="text-align:center">较难</td><td style="text-align:center">较易</td></tr></tbody></table><h4 id="InnoDB索引结构"><a href="#InnoDB索引结构" class="headerlink" title="InnoDB索引结构"></a>InnoDB索引结构</h4><p>&emsp;&emsp;InnoDB使用B+Tree作为索引结构，InnoDB的数据文件本身就是索引文件，<strong>叶节点保存了完整的数据记录</strong>。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p><p><img src="https://raw.githubusercontent.com/chung567115/chung567115.github.io/hexo-blog/blog-img/32-1.png" alt="InnoDB"></p><blockquote><p>上图是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做<kbd><strong>聚集索引</strong></kbd>。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p></blockquote><p>&emsp;&emsp;除此之外，InnoDB的辅助索引data域存储相应记录<strong>主键</strong>的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域，如下图辅助索引：</p><p><img src="https://raw.githubusercontent.com/chung567115/chung567115.github.io/hexo-blog/blog-img/32-2.png" alt="InnoDB"><br>&emsp;&emsp;聚集索引这种实现方式使得按主键的搜索十分高效，但是<strong>辅助索引搜索需要走两遍索引</strong>：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p><blockquote><p>了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</p></blockquote><h4 id="MyISAM索引结构"><a href="#MyISAM索引结构" class="headerlink" title="MyISAM索引结构"></a>MyISAM索引结构</h4><p>&emsp;&emsp;MyISAM引擎也使用B+Tree作为索引结构，但具体实现方式却与InnoDB截然不同，MyISAM索引文件和数据文件是分离的，<strong>叶节点存放的是数据记录的地址</strong>。<br><img src="https://raw.githubusercontent.com/chung567115/chung567115.github.io/hexo-blog/blog-img/32-3.png" alt="MyISAM"></p><p>&emsp;&emsp;在MyISAM中，主索引和辅助索引在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。辅助索引的结构如下图所示：</p><p><img src="https://raw.githubusercontent.com/chung567115/chung567115.github.io/hexo-blog/blog-img/32-4.png" alt="MyISAM"><br>&emsp;&emsp;MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p><blockquote><p>MyISAM的索引方式也叫做<kbd><strong>非聚集索引</strong></kbd>，之所以这么称呼是为了与InnoDB的聚集索引区分。</p></blockquote><h3 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h3><p>&emsp;&emsp;数据库索引包括<code>B+树索引</code>、<code>R树索引</code>、<code>Hash索引</code>、<code>FullText索引</code>等。  </p><h4 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h4><p>&emsp;&emsp;一棵 $m$  阶 B 树，或为空树，或满足：<br>​    1. 每个结点至多有 $m$ 棵子树。<br>​    2. 若根结点不是叶子，则至少有两棵子树。<br>​    3. 除根之外的所有非终端结点至少有 $\frac{m}{2}$  棵子树。<br>​    4. 所有非终端结点包含 $n$ 个关键字和 $n+1$ 棵子树，$n$ 满足：$\frac{m}{2} - 1 \leq n \leq m-1$。<br>​    5. 所有叶子结点在同一层，不含信息，表示查找失败。</p><h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><p>&emsp;&emsp;一棵 $m$ 阶 B+ 树，或为空树，或满足：<br>​    1. 根结点只有一个，分支数量范围为$[2，m]$。<br>​    2. 每个分支结点包含分支数范围为$[\frac{m}{2}，m]$。<br>​    3. 分支结点的关键字数量等于其子分支的数量减一，关键字数量范围为$[\frac{m}{2} - 1， m - 1]$，关键字<strong>顺序递增</strong>。<br>​    4. 所有叶子结点在同一层。</p><p>&emsp;&emsp;由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫。其中B树和B+树的区别如下：  </p><ul><li><strong>关键字数量不同</strong>；B+树中 n 棵子树的结点中含有 n 个关键字；B树中 m 棵子树的结点中含有 m - 1 个关键字。</li><li><strong>存储位置不同</strong>；B+树中所有叶子结点中包含了全部关键字，且按大小顺序排列；B树的数据存储在每一个结点中，并不仅仅存储在叶子结点上。</li><li><strong>分支结点构造不同</strong>；B+树中所有非终端结点都是索引；B树中非终端结点存储数据。</li><li><strong>查找方式不同</strong>；B+树中查找时走了一条从根结点到叶子结点的路径；B树中在找到具体的数值以后就结束，并不一定到叶子结点。</li></ul><blockquote><p>B树：有序数组+平衡多叉树；<br>B+树：有序数组链表+平衡多叉树；</p></blockquote><p>&emsp;&emsp;B+树的关键字全部存放在叶子节点中，非叶子节点用来做索引，而叶子节点中有一个指针指向一下个叶子节点。做这个优化的目的是为了提高<strong>区间访问的性能</strong>。而正是这个特性决定了B+树更适合用来存储外部数据。</p><h4 id="R树（空间索引）"><a href="#R树（空间索引）" class="headerlink" title="R树（空间索引）"></a>R树（空间索引）</h4><p>&emsp;&emsp;一棵R树满足如下的性质：  </p><ol><li>除根结点之外，所有非根结点包含有 m 至 M 个记录索引，根结点的记录个数可以少于 m 。通常 M = 2m 。</li><li>对于所有叶子结点中存储的记录，I 是最小的可以在空间中完全覆盖这些记录所代表的点的矩形（此处“矩形”可以扩展到高维空间）。</li><li>对于所有非叶子结点上的记录，i 是最小的可以在空间上完全覆盖这些条目所代表的点的矩形。</li><li>所有叶子结点在同一层。</li></ol><blockquote><p>R树是B树在K维上的自然扩展</p></blockquote><h4 id="为什么要使用B-树"><a href="#为什么要使用B-树" class="headerlink" title="为什么要使用B+树"></a>为什么要使用B+树</h4><p>&emsp;&emsp;数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。<strong>B+树中一次检索最多需要 h-1 次 I/O（根节点常驻内存）</strong>，渐进复杂度为$O(h)=O(\log_d N)$。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。<br>因此，使用B+树作为索引结构效率是非常高的。<br>&emsp;&emsp;而红黑树这种结构，h明显要深的多，所以红黑树的索引结构效率很低。另一方面，由于逻辑上很近的节点（父子）物理上可能很远，导致无法利用局部性一次性载入内存，所以红黑树的 I/O 也比B+树大得多。</p><h4 id="最左前缀原理"><a href="#最左前缀原理" class="headerlink" title="最左前缀原理"></a>最左前缀原理</h4><p>&emsp;&emsp;例如有表table，含a、b、c、d四列，有联合索引&lt;a, b, c&gt;。</p><ol><li><p>全列匹配</p> <div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 当按照索引中所有列进行精确匹配（= 或 IN）时，会走索引</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_test <span class="keyword">WHERE</span> a=<span class="string">'1'</span> <span class="keyword">AND</span> b=<span class="string">'2'</span> <span class="keyword">AND</span> c=<span class="string">'3'</span>; <span class="comment">-- a,b,c都走索引</span></span><br></pre></td></tr></table></figure></div></li><li><p>最左前缀匹配</p> <div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 当查询条件精确匹配索引的左边连续一列或几列时，会走（条件所组成的最左前缀）索引。</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_test <span class="keyword">WHERE</span> a=<span class="string">'1'</span>; <span class="comment">-- a走索引</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_test <span class="keyword">WHERE</span> a=<span class="string">'1'</span> <span class="keyword">AND</span> b=<span class="string">'2'</span>; <span class="comment">-- a,b都走索引</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_test <span class="keyword">WHERE</span> a=<span class="string">'1'</span> <span class="keyword">AND</span> c=<span class="string">'3'</span>; <span class="comment">-- a走索引，c不走索引</span></span><br></pre></td></tr></table></figure></div></li><li><p>查询条件没有指定索引第一列</p> <div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 当查询条件不满足最左前缀，则不会走索引</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_test <span class="keyword">WHERE</span> b=<span class="string">'2'</span>; <span class="comment">-- 不走索引</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_test <span class="keyword">WHERE</span> c=<span class="string">'3'</span>; <span class="comment">-- 不走索引</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_test <span class="keyword">WHERE</span> b=<span class="string">'2'</span> <span class="keyword">AND</span> c=<span class="string">'3'</span>; <span class="comment">-- b,c都不走索引</span></span><br></pre></td></tr></table></figure></div></li><li><p>匹配某列的前缀字符串</p> <div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 可以用到索引，但根据具体情况不同可能只会用其中一个前缀</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_test <span class="keyword">WHERE</span> a=<span class="string">'1'</span> <span class="keyword">AND</span> b <span class="keyword">LIKE</span> <span class="string">'2%'</span>;</span><br></pre></td></tr></table></figure></div></li><li><p>范围查询</p> <div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 范围列可以用到索引（必须是最左前缀），但是范围列后面的列无法用到索引。</span></span><br><span class="line"><span class="comment">-- 索引最多用于一个范围列，查询条件中有两个范围列时无法全用到索引。</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_test <span class="keyword">WHERE</span> a&lt;<span class="string">'1'</span> <span class="keyword">AND</span> b=<span class="string">'2'</span>; <span class="comment">-- a走索引，b不走索引</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_test <span class="keyword">WHERE</span> b&lt;<span class="string">'2'</span> <span class="keyword">AND</span> c&gt;<span class="string">'3'</span>; <span class="comment">-- b,c都不走索引</span></span><br></pre></td></tr></table></figure></div></li><li><p>查询条件含函数或表达式</p> <div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 如果查询条件中含有函数或表达式，MySQL不会为这列使用索引</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_test <span class="keyword">WHERE</span> <span class="keyword">left</span>(a, <span class="number">1</span>)=<span class="string">'1'</span>; <span class="comment">--不走索引</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_test <span class="keyword">WHERE</span> a=<span class="string">'1'</span> <span class="keyword">AND</span> <span class="keyword">left</span>(b, <span class="number">1</span>)=<span class="string">'2'</span>; <span class="comment">-- a走索引，b不走索引</span></span><br></pre></td></tr></table></figure></div></li></ol><h3 id="左右连接查询"><a href="#左右连接查询" class="headerlink" title="左右连接查询"></a>左右连接查询</h3><ol><li>左连接(left join)：显示左表所有数据和右表相应数据。</li><li>右连接(right join)：显示右表所有数据加左表相应数据。</li><li>内连接(inner join)：显示有效公共数据。</li><li>全连接(full join)：显示所有数据。</li></ol><blockquote><p><strong>左连接只影响右表，右连接只影响左表</strong></p></blockquote><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h3><p>&emsp;&emsp;基于C语言开发的一种非关系型数据库，数据放在内存，使用<strong>RDB</strong>[快照]方式或者<strong>AOF</strong>[日志]方式持久化。<br>&emsp;&emsp;Redis的优势包括速度、对富数据类型的支持（String、Hash、List、Set、Zset）、原子性操作、通用性。</p><h3 id="Redis使用场景"><a href="#Redis使用场景" class="headerlink" title="Redis使用场景"></a>Redis使用场景</h3><ul><li>缓存（<strong>热数据</strong>：经常被查询，但不常被改变的数据）</li><li>共享Session（SSO系统）</li><li>队列 / 栈</li><li>位操作（<strong>大数据处理</strong>）</li><li>分布式锁(<strong>setnx命令</strong>)与单线程机制（<strong>秒杀系统</strong>）</li><li>排行榜 / 计数器（<strong>ZSet的zadd命令</strong>）</li><li>发布 / 订阅</li></ul><h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><h3 id="第一范式（1NF）"><a href="#第一范式（1NF）" class="headerlink" title="第一范式（1NF）"></a>第一范式（1NF）</h3><p>&emsp;&emsp;所谓第一范式（1NF）是指在关系模型中，对域添加的一个规范要求，所有的域都应该是原子性的，即数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项。即实体中的某个属性有多个值时，必须拆分为不同的属性。在符合第一范式（1NF）表中的每个域值只能是实体的一个属性或一个属性的一部分。  </p><blockquote><p>简而言之，第一范式就是无重复的域。</p></blockquote><h3 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h3><p>&emsp;&emsp;在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖）。第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或记录必须可以被唯一地区分，选取一个能区分每个实体的属性或属性组，作为实体的唯一标识。  </p><blockquote><p>简而言之，第二范式就是在满足第一范式的基础上，属性完全依赖于主键。</p></blockquote><h3 id="第三范式（3NF）"><a href="#第三范式（3NF）" class="headerlink" title="第三范式（3NF）"></a>第三范式（3NF）</h3><p>&emsp;&emsp;在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）。第三范式（3NF）是第二范式（2NF）的一个子集，即满足第三范式（3NF）必须满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个关系中不包含已在其它关系已包含的非主关键字信息。  </p><blockquote><p>简而言之，第三范式就是在满足第二范式的基础上，属性不依赖于其它非主属性。</p></blockquote><h2 id="分库后如何实现分页查询"><a href="#分库后如何实现分页查询" class="headerlink" title="分库后如何实现分页查询"></a>分库后如何实现分页查询</h2><ol><li>直接使用跨库的多表联合查询（不建议）。</li><li>向每个数据库均发送一个查询请求，然后对所有查询结果汇总，再处理分页逻辑。</li><li>建立一个总数据库，只负责维护主键和必要的索引，以供分页查询。</li><li>使用Redis维护一个主键序列，分页操作就是截取该序列的一部分，其结果就是主键ID集合，拿到ID后便可映射到多个数据库查询数据。</li></ol><blockquote><p>“多台”数据库访问的问题无解，但同台“多次”数据库访问的问题可以通过程序优化。</p></blockquote><h2 id="SQL注入的原理，如何预防"><a href="#SQL注入的原理，如何预防" class="headerlink" title="SQL注入的原理，如何预防"></a>SQL注入的原理，如何预防</h2><p>&emsp;&emsp;所谓SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。  </p><ol><li>对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双”-“进行转换等。</li><li>不要使用动态拼装SQL，应使用参数化的SQL或者直接使用存储过程进行数据查询存取。</li><li>不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。</li><li>不要把机密信息明文存放，应加密或者Hash掉密码和敏感的信息。</li><li>使用自定义的错误信息对原始错误信息进行包装，把异常信息存放在独立的表中。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;笔经面经归纳汇总：数据库&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="笔经面经" scheme="http://zhangchong.xin/categories/%E7%AC%94%E7%BB%8F%E9%9D%A2%E7%BB%8F/"/>
    
    
      <category term="Java" scheme="http://zhangchong.xin/tags/Java/"/>
    
      <category term="校招" scheme="http://zhangchong.xin/tags/%E6%A0%A1%E6%8B%9B/"/>
    
  </entry>
  
  <entry>
    <title>Java面试之计算机网络</title>
    <link href="http://zhangchong.xin/2018/07/21/Java%20%E9%9D%A2%E8%AF%95%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>http://zhangchong.xin/2018/07/21/Java 面试之计算机网络/</id>
    <published>2018-07-21T03:12:57.000Z</published>
    <updated>2019-03-12T11:24:53.149Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>笔经面经归纳汇总：计算机网络</p></blockquote><a id="more"></a><h1 id="Java面试之计算机网络"><a href="#Java面试之计算机网络" class="headerlink" title="Java面试之计算机网络"></a>Java面试之计算机网络</h1><h2 id="OSI与TCP-IP各层"><a href="#OSI与TCP-IP各层" class="headerlink" title="OSI与TCP/IP各层"></a>OSI与TCP/IP各层</h2><p><img src="https://raw.githubusercontent.com/chung567115/chung567115.github.io/hexo-blog/blog-img/31-1.png" alt="OSI与TCP/IP结构"></p><h2 id="TCP、HTTP"><a href="#TCP、HTTP" class="headerlink" title="TCP、HTTP"></a>TCP、HTTP</h2><h3 id="TCP三次握手、四次挥手"><a href="#TCP三次握手、四次挥手" class="headerlink" title="TCP三次握手、四次挥手"></a>TCP三次握手、四次挥手</h3><h4 id="TCP三次握手（建立连接）"><a href="#TCP三次握手（建立连接）" class="headerlink" title="TCP三次握手（建立连接）"></a>TCP三次握手（建立连接）</h4><ol><li>第一次握手：客户端向服务器发送SYN(seq=j)包到服务器；</li><li>第二次握手：服务器收到SYN包，向客户端发送ACK包(ack=j+1)和SYN包(seq=k)；</li><li>第三次握手：客户端收到SYN＋ACK包，向服务器发送ACK包(ack=k+1)，完成三次握手。<br><img src="https://raw.githubusercontent.com/chung567115/chung567115.github.io/hexo-blog/blog-img/31-2.png" alt="三次握手"></li></ol><h4 id="TCP四次挥手（终止连接）"><a href="#TCP四次挥手（终止连接）" class="headerlink" title="TCP四次挥手（终止连接）"></a>TCP四次挥手（终止连接）</h4><ol><li>第一次挥手：客户端向服务器发送FIN包(seq=j)，关闭客户到服务器的数据传送；</li><li>第二次挥手：服务器收到FIN包，向客户端发送ACK包(ack=j+1)；</li><li>第三次挥手：服务器向客户端发送FIN包(seq=k)；</li><li>第四次挥手：客户端收到FIN包，向客户端发送ACK包(ack=k+1)，完成四次挥手。<br><img src="https://raw.githubusercontent.com/chung567115/chung567115.github.io/hexo-blog/blog-img/31-3.png" alt="四次挥手"></li></ol><h4 id="为什么TCP连接是3次而终止是4次"><a href="#为什么TCP连接是3次而终止是4次" class="headerlink" title="为什么TCP连接是3次而终止是4次"></a>为什么TCP连接是3次而终止是4次</h4><p>&emsp;&emsp;连接时，服务端收到SYN后，把ACK和SYN一起打包回发给客户端，只有3次。<br>&emsp;&emsp;终止时，由于TCP连接是全双工的，每个方向都必须单独进行关闭，即FIN和ACK是分开发送的，所以有4次。<br>&emsp;&emsp;当一方完成它的数据发送任务后，发送一个FIN来终止连接。但收到一个FIN只表示对方没有数据发送，而己方仍能发送数据。因此必须单独关闭。  </p><h3 id="HTTP相关"><a href="#HTTP相关" class="headerlink" title="HTTP相关"></a>HTTP相关</h3><h4 id="HTTP的状态码含义"><a href="#HTTP的状态码含义" class="headerlink" title="HTTP的状态码含义"></a>HTTP的状态码含义</h4><table><thead><tr><th style="text-align:center">分类</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1xx</td><td style="text-align:center">信息，服务器收到请求，需要请求者继续执行操作</td></tr><tr><td style="text-align:center">2xx</td><td style="text-align:center">成功，操作被成功接收并处理</td></tr><tr><td style="text-align:center">3xx</td><td style="text-align:center">重定向，需要进一步的操作以完成请求</td></tr><tr><td style="text-align:center">4xx</td><td style="text-align:center">请求错误，请求包含语法错误或无法完成请求</td></tr><tr><td style="text-align:center">5xx</td><td style="text-align:center">服务器错误，服务器在处理请求时发生错误</td></tr></tbody></table><h4 id="HTTP-Request的几种类型"><a href="#HTTP-Request的几种类型" class="headerlink" title="HTTP Request的几种类型"></a>HTTP Request的几种类型</h4><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">描述</th><th style="text-align:center">幂等性</th><th style="text-align:center">安全性</th></tr></thead><tbody><tr><td style="text-align:center">POST</td><td style="text-align:center">向指定资源提交数据进行处理请求（例如提交表单或上传文件）</td><td style="text-align:center">否</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">PUT</td><td style="text-align:center">向指定资源位置上传其最新内容</td><td style="text-align:center">是</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">DELETE</td><td style="text-align:center">请求服务器删除所标识的资源</td><td style="text-align:center">是</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">GET</td><td style="text-align:center">向特定的资源发出请求</td><td style="text-align:center">是</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">HEAD</td><td style="text-align:center">向服务器索要与GET请求相一致的响应，不过响应体不会被返回</td><td style="text-align:center">是</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">OPTIONS</td><td style="text-align:center">返回服务器针对特定资源所支持的HTTP请求方法</td><td style="text-align:center">是</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">TRACE</td><td style="text-align:center">回显服务器收到的请求，主要用于测试或诊断</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">CONNECT</td><td style="text-align:center">HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr></tbody></table><blockquote><p>幂等性指该方法多次调用最终资源状态是一样的。<br>安全性指访问资源的时候资源本身不会发生改变。</p></blockquote><h4 id="HTTP-1-0、HTTP1-1、HTTP2-0"><a href="#HTTP-1-0、HTTP1-1、HTTP2-0" class="headerlink" title="HTTP 1.0、HTTP1.1、HTTP2.0"></a>HTTP 1.0、HTTP1.1、HTTP2.0</h4><ul><li>HTTP 1.0中，客户端的每次请求都要建立一次单独的连接，在处理完本次请求后，就自动释放连接。</li><li>HTTP 1.1中，支持<strong>长连接</strong>和<strong>流水线请求</strong>处理，在一个TCP连接上可以传送多个HTTP请求和响应，若干个请求串行化<strong>单线程</strong>处理。</li><li>HTTP2.0中，基于<strong>二进制解析</strong>，可<strong>多路复用</strong>，多个请求可同时在一个连接上<strong>并行处理</strong>。</li></ul><p><img src="https://raw.githubusercontent.com/chung567115/chung567115.github.io/hexo-blog/blog-img/31-4.png" alt="HTTP比较"></p><h3 id="TCP与HTTP的报文结构"><a href="#TCP与HTTP的报文结构" class="headerlink" title="TCP与HTTP的报文结构"></a>TCP与HTTP的报文结构</h3><p><img src="https://raw.githubusercontent.com/chung567115/chung567115.github.io/hexo-blog/blog-img/31-5.png" alt="tcp报文结构"><br><img src="https://raw.githubusercontent.com/chung567115/chung567115.github.io/hexo-blog/blog-img/31-6.png" alt="http报文结构"></p><h2 id="Forward与Redirect"><a href="#Forward与Redirect" class="headerlink" title="Forward与Redirect"></a>Forward与Redirect</h2><ul><li>直接转发（Forward）：也称<strong>转发</strong>，浏览器发出请求，服务器把响应内容读取过来，然后再把这些内容发给浏览器。<strong>地址栏显示原来的URL</strong>。</li><li>间接转发（Redirect）：也称<strong>重定向</strong>，浏览器发出请求，服务器端在响应第一次请求的时候，让浏览器向另一个地址发出请求，然后得到响应。<strong>地址栏显示新的URL</strong>。</li></ul><h2 id="Cookie与Session"><a href="#Cookie与Session" class="headerlink" title="Cookie与Session"></a>Cookie与Session</h2><ul><li>Cookie：为了辨别用户身份而储存在客户端的数据。服务器在Http响应头中添加Set-Cookie信息，浏览器收到响应后会根据头中的字段保存Cookie，下一次访问时在请求头中附带Cookie内容，供服务器根据Cookie值进行后续处理。</li><li>Session：为了保存用户信息而储存在服务端的数据。当客户端第一次访问时，服务器会计算出一个sessionID，创建一个对应的Session对象并存储；然后将sessionID保存至浏览器Cookie，下一次访问时服务器根据sessionID来匹配Session，Session中可以存一些键值对。</li></ul><blockquote><p>Cookie最典型的应用是：①判断用户是否登陆过网站，以便下次登录时能够直接登录。②购物车信息处理。</p></blockquote><h2 id="访问一个网页全过程"><a href="#访问一个网页全过程" class="headerlink" title="访问一个网页全过程"></a>访问一个网页全过程</h2><ol><li>输入URL；</li><li>DNS将域名解析成IP地址；</li><li>建立TCP连接；</li><li>OSPF（内部网关协议）决定经过哪些路由器，ARP（地址解析协议）负责求下一个节点地址；</li><li>发送HTTP请求；</li><li>得到响应，展现HTML界面。</li></ol><h2 id="使用Socket通信的几个关键函数"><a href="#使用Socket通信的几个关键函数" class="headerlink" title="使用Socket通信的几个关键函数"></a>使用Socket通信的几个关键函数</h2><ol><li>初始化socket：<code>int socket(int domain, int type, int protocol);</code><ul><li>domain ：指定通信协议族。</li><li>type：指定socket类型。</li><li>protocol ：协议类型。</li><li>返回值：成功返回非负整数。</li></ul></li><li>绑定端口：<code>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code><ul><li>sockfd：socket函数返回的套接字。</li><li>addr：要绑定的地址。</li><li>addrlen：地址长度。</li><li>返回值：成功返回0，失败返回-1。</li></ul></li><li>监听端口：<code>int listen(int sockfd, int backlog);</code><ul><li>sockfd：socket函数返回的套接字。</li><li>backlog：已完成三次握手的最大连接个数。</li><li>返回值：成功返回0，失败返回-1。</li></ul></li><li>响应连接请求：<code>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</code><ul><li>sockfd：服务器套接字。</li><li>addr：将返回对等方的套接字地址。</li><li>addrlen：返回对等方的套接字地址长度。</li><li>返回值：成功返回非负整数，失败返回-1。</li></ul></li><li>建立连接：<code>int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code><ul><li>sockfd：未连接套接字。</li><li>addr：要连接的套接字地址。</li><li>addrlen：第二个参数addr长度。</li><li>返回值：成功返回0，失败返回-1。</li></ul></li></ol><h2 id="IP地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a>IP地址分类</h2><p><img src="https://raw.githubusercontent.com/chung567115/chung567115.github.io/hexo-blog/blog-img/31-7.png" alt="IP地址分类"></p><h2 id="交换机与路由器区别"><a href="#交换机与路由器区别" class="headerlink" title="交换机与路由器区别"></a>交换机与路由器区别</h2><table><thead><tr><th style="text-align:center">比较点</th><th style="text-align:center">交换机</th><th style="text-align:center">路由器</th></tr></thead><tbody><tr><td style="text-align:center">作用</td><td style="text-align:center">用于网络内部数据交换</td><td style="text-align:center">用于不同网络间数据传输</td></tr><tr><td style="text-align:center">工作层</td><td style="text-align:center">数据链路层</td><td style="text-align:center">网络层</td></tr><tr><td style="text-align:center">处理方式</td><td style="text-align:center">硬件处理</td><td style="text-align:center">软件处理</td></tr><tr><td style="text-align:center">工作依靠</td><td style="text-align:center">MAC地址</td><td style="text-align:center">IP地址</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;笔经面经归纳汇总：计算机网络&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="笔经面经" scheme="http://zhangchong.xin/categories/%E7%AC%94%E7%BB%8F%E9%9D%A2%E7%BB%8F/"/>
    
    
      <category term="Java" scheme="http://zhangchong.xin/tags/Java/"/>
    
      <category term="校招" scheme="http://zhangchong.xin/tags/%E6%A0%A1%E6%8B%9B/"/>
    
  </entry>
  
  <entry>
    <title>Java面试之操作系统</title>
    <link href="http://zhangchong.xin/2018/07/21/Java%20%E9%9D%A2%E8%AF%95%E4%B9%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://zhangchong.xin/2018/07/21/Java 面试之操作系统/</id>
    <published>2018-07-21T03:12:30.000Z</published>
    <updated>2019-03-12T11:21:39.665Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>笔经面经归纳汇总：计算机操作系统</p></blockquote><a id="more"></a><h1 id="Java面试之操作系统"><a href="#Java面试之操作系统" class="headerlink" title="Java面试之操作系统"></a>Java面试之操作系统</h1><h2 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h2><ul><li>cd命令：切换目录</li><li>ls命令：查看文件与目录</li><li>cp命令：复制文件</li><li>mv命令：移动文件或文件夹</li><li>rm命令：删除文件或文件夹</li><li>mkdir命令：创建文件夹</li><li>grep命令：用于查找文件里符合条件的字符串</li><li>chmod命令：改变文件权限</li><li>ps命令：进程运行情况</li><li>kill命令：停止进程</li><li>atop / htop命令：查看CPU、内存、磁盘、网络等信息 / 查看CPU、内存、进程等实时信息</li><li>tar命令：文件压缩 / 解压</li><li>vim命令：文本编辑</li><li>gcc命令：编译</li></ul><h2 id="内存管理方式"><a href="#内存管理方式" class="headerlink" title="内存管理方式"></a>内存管理方式</h2><p>&emsp;&emsp;用户程序的逻辑地址空间被划分成若干固定大小的区域，称为页或者页面，相应地，内存物理空间也分成相对应的若干个物理块，页和块的大小相等。可将用户程序的任一页放在内存的任一块中，实现了<strong>离散分配</strong>。  </p><h3 id="页存储"><a href="#页存储" class="headerlink" title="页存储"></a>页存储</h3><p>&emsp;&emsp;为了便于在内存中找到进程的每个页面所对应的物理块，系统为每个进程建立一张页表，记录页面在内存中对应的物理块号，页表一般存放在内存中。在配置了页表后，进程执行时，通过查找该表，即可找到每页在内存中的物理块号。可见页表作用是实现从页号到物理块号的地址映射，这种是<strong>页存储</strong>管理方式。如下图所示：<br><img src="https://raw.githubusercontent.com/chung567115/chung567115.github.io/hexo-blog/blog-img/30-1.png" alt="页表"></p><h3 id="段存储"><a href="#段存储" class="headerlink" title="段存储"></a>段存储</h3><p>&emsp;&emsp;将用户程序地址空间分成若干个大小不等的段，每段可以定义一组相对完整的逻辑信息。存储分配时，以段为单位，段与段在内存中可以不相邻接，也实现了离散分配，这种是<strong>段存储</strong>管理方式。如下图所示：<br><img src="https://raw.githubusercontent.com/chung567115/chung567115.github.io/hexo-blog/blog-img/30-2.png" alt="段表"></p><h3 id="段页存储"><a href="#段页存储" class="headerlink" title="段页存储"></a>段页存储</h3><p>&emsp;&emsp;作业的地址空间首先被分成若干个逻辑分段，每段都有自己的段号，然后再将每段分成若干个大小相等的页。对于主存空间也分成大小相等的页，主存的分配以页为单位，这种是<strong>段页存储</strong>管理方式。如下图所示：<br><img src="https://raw.githubusercontent.com/chung567115/chung567115.github.io/hexo-blog/blog-img/30-3.png" alt="段页表"></p><h2 id="物理地址、逻辑地址、虚拟地址"><a href="#物理地址、逻辑地址、虚拟地址" class="headerlink" title="物理地址、逻辑地址、虚拟地址"></a>物理地址、逻辑地址、虚拟地址</h2><ul><li>物理地址：内存单元所限定地址范围中的地址（CPU地址总线传来的地址）。</li><li>逻辑地址：也叫相对地址，机器语言指令中，用来指定一个操作数或一条指令的地址。</li><li>虚拟地址：也叫线性地址，是逻辑地址到物理地址变换之间的中间层。</li></ul><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>&emsp;&emsp;虚拟存储器是指<strong>具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统</strong>。<br>&emsp;&emsp;应用程序在运行之前，仅须将那些当前要运行的少数页面或段先装入内存便可运行。程序在运行时，如果它所要访问的页(段)已调入内存，便可继续执行下去；但如果缺页或缺段，此时程序应利用 OS 所提供的请求调页(段)功能，将它们调入内存，以使进程能继续执行下去。如果此时内存已满，则还须再利用页(段)的置换功能。这样，便可使一个大的用户程序能在较小的内存空间中运行，也可在内存中同时装入更多的进程使它们并发执行。从用户角度看，该系统所具有的内存容量，将比实际内存容量大得多，故人们把这样的存储器称为虚拟存储器。  </p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;笔经面经归纳汇总：计算机操作系统&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="笔经面经" scheme="http://zhangchong.xin/categories/%E7%AC%94%E7%BB%8F%E9%9D%A2%E7%BB%8F/"/>
    
    
      <category term="Java" scheme="http://zhangchong.xin/tags/Java/"/>
    
      <category term="校招" scheme="http://zhangchong.xin/tags/%E6%A0%A1%E6%8B%9B/"/>
    
  </entry>
  
  <entry>
    <title>Java面试之算法</title>
    <link href="http://zhangchong.xin/2018/07/21/Java%20%E9%9D%A2%E8%AF%95%E4%B9%8B%E7%AE%97%E6%B3%95/"/>
    <id>http://zhangchong.xin/2018/07/21/Java 面试之算法/</id>
    <published>2018-07-21T03:11:49.000Z</published>
    <updated>2019-03-12T11:23:49.769Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>笔经面经归纳汇总：算法</p></blockquote><a id="more"></a><h1 id="Java面试之算法"><a href="#Java面试之算法" class="headerlink" title="Java面试之算法"></a>Java面试之算法</h1><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p><img src="https://raw.githubusercontent.com/chung567115/chung567115.github.io/hexo-blog/blog-img/29-1.png" alt="排序"></p><p> &emsp;&emsp;名词解释：  </p><ul><li>n: 数据规模</li><li>k: “桶”的个数</li><li>In-place: 占用常数内存，不占用额外内存</li><li>Out-place: 占用额外内存</li></ul><h3 id="快排的Partition函数与归并的Merge函数"><a href="#快排的Partition函数与归并的Merge函数" class="headerlink" title="快排的Partition函数与归并的Merge函数"></a>快排的Partition函数与归并的Merge函数</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(T a[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="comment">/************ Partition 函数**************/</span></span><br><span class="line">        pivot = a[low];</span><br><span class="line">        i = low; j = high;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; a[j] &gt;= pivot) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            a[i] = a[j];</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; a[i] &lt;= pivot) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            a[j] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        a[i] = pivot;</span><br><span class="line">        <span class="comment">/*****************************************/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对子序列快排</span></span><br><span class="line">        QuickSort(a, low, i<span class="number">-1</span>);</span><br><span class="line">        QuickSort(a, i+<span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span> <span class="params">( T a[], <span class="keyword">int</span> low, <span class="keyword">int</span> high )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( low &gt;= high ) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        MergeSort(a, low, mid);</span><br><span class="line">        MergeSort(a, mid+<span class="number">1</span>, high);</span><br><span class="line">        Merge(a, low, mid, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/****************** Merge 函数*********************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(T a[], <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 归并到 b[]</span></span><br><span class="line">    i = low; </span><br><span class="line">    k = low;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= high ) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt;= a[j]) &#123; </span><br><span class="line">            b[k] = a[i]; i++; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            b[k] = a[j]; j++; </span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 归并剩余元素</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) &#123;</span><br><span class="line">        b[k++] = a[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= high) &#123;</span><br><span class="line">        b[k++] = a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从 b[]复制回 a[]</span></span><br><span class="line">    a[low..high] = b[low..high];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*************************************************/</span></span><br></pre></td></tr></table></figure></div><blockquote><p>排序详解可参考博文 <a href="https://www.cnblogs.com/onepixel/articles/7674659.html" target="_blank" rel="noopener">https://www.cnblogs.com/onepixel/articles/7674659.html</a></p></blockquote><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">( DataType a[], <span class="keyword">int</span> low, <span class="keyword">int</span> high, DataType x )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( low&gt;high ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 查找失败</span></span><br><span class="line">    &#125;</span><br><span class="line">    mid = (low + high) / <span class="number">2</span>; <span class="comment">// 折半</span></span><br><span class="line">    <span class="keyword">if</span> ( a[mid] == x ) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid; <span class="comment">// 找到</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( x &lt; a[mid] ) &#123;</span><br><span class="line">        <span class="keyword">return</span> BinarySearch(a, low, mid - <span class="number">1</span>, x);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BinarySearch(a, mid + <span class="number">1</span>, high, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="图的DFS算法与BFS算法"><a href="#图的DFS算法与BFS算法" class="headerlink" title="图的DFS算法与BFS算法"></a>图的DFS算法与BFS算法</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DFS 深度优先搜索</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(Graph G)</span> </span>&#123;</span><br><span class="line">    visited [<span class="number">0.</span>.G.vexnum<span class="number">-1</span>] = <span class="literal">false</span>; <span class="comment">// 初始化访问标志为未访问(false)</span></span><br><span class="line">    <span class="keyword">for</span>(v = <span class="number">0</span>; v &lt; G.vexnum; v++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[v]) &#123;</span><br><span class="line">            DFS(G, v); <span class="comment">// 从未被访问的顶点开始 DFS</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Graph G, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    visit ( v ); </span><br><span class="line">    visited [v] = <span class="literal">true</span>; <span class="comment">// 访问顶点 v 并作标记</span></span><br><span class="line">    <span class="keyword">for</span>(w = FirstAdjVex(G,v); w &gt;= <span class="number">0</span>; w = NextAdjVex(G,v,w)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[w]) &#123;</span><br><span class="line">            DFS(G, w); <span class="comment">// 分别从每个未访问的邻接点开始 DFS</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// BFS 广度优先搜索</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">(Graph G)</span> </span>&#123;</span><br><span class="line">    visited[<span class="number">0.</span>.G.vexnum<span class="number">-1</span>] = <span class="literal">false</span>; <span class="comment">// 初始化访问标志为未访问(false)</span></span><br><span class="line">    InitQueue(Q);</span><br><span class="line">    <span class="keyword">for</span>(v = <span class="number">0</span>; v &lt; G.vexnum; v++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[v]) &#123;</span><br><span class="line">            <span class="comment">// 从 v 出发广度优先搜索</span></span><br><span class="line">            visit(v); </span><br><span class="line">            visited [v] = <span class="literal">true</span>;</span><br><span class="line">            EnQueue(Q, v);</span><br><span class="line">            <span class="keyword">while</span>(!QueueEmpty(Q)) &#123;</span><br><span class="line">                DeQueue(Q, u);</span><br><span class="line">                <span class="keyword">for</span>(w = FirstAdjVex(G, u); w &gt;= <span class="number">0</span>; w = NextAdjVex(G, u, w)) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!visited[w]) &#123;</span><br><span class="line">                        visit(w); </span><br><span class="line">                        visited[w] = <span class="literal">true</span>;</span><br><span class="line">                        EnQueue(Q, w);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="最小生成树Kruskal算法、Prim算法"><a href="#最小生成树Kruskal算法、Prim算法" class="headerlink" title="最小生成树Kruskal算法、Prim算法"></a>最小生成树Kruskal算法、Prim算法</h2><ul><li>Kruskal：不构成环的情况下，每次选取最小边（边较少时特别有效）。</li><li>Prim：记 $V$ 是连通网的顶点集， $U$ 是求得生成树的顶点集， $TE$ 是求得生成树的边集：<ol><li>开始时， $U={v_0}$， $TE = \Phi$；</li><li>计算 $U$ 到其余顶点 $V-U$ 的最小代价，将该顶点纳入 $U$，边纳入 $TE$；</li><li>重复 2 直到 $U=V$。</li></ol></li></ul><blockquote><p>同一个连通网的最小生成树可能是不唯一的，但其代价都是最小(唯一的)。</p></blockquote><h2 id="最短路径Dijkstra算法-、Floyd算法"><a href="#最短路径Dijkstra算法-、Floyd算法" class="headerlink" title="最短路径Dijkstra算法  、Floyd算法"></a>最短路径Dijkstra算法  、Floyd算法</h2><ul><li><p>Dijkstra：求一个顶点到其他各顶点的最短路径：</p><ol><li>初始化：用起点 v 到该顶点 w 的直接边(弧)初始化最短路径，否则设为 $\infty$；</li><li>从未求得最短路径的终点中选择路径长度最小的终点 $u$：即求得 $v$ 到 $u$ 的最短路径；</li><li>修改最短路径：计算 $u$ 的邻接点的最短路径，若$(v,…,u)+(u,w)&lt;(v,…,w)$，则以<br>$(v,…,u,w)$代替。</li><li>重复 2–3，直到求得 $v$ 到其余所有顶点的最短路径。</li></ol></li><li><p>Floyd：求每对顶点之间的最短路径：<br>  &emsp;&emsp;依次计算 $A^{(0)}$， $A^{(1)}$， …， $A^{(n)}$。 $A^{(0)}$为邻接矩阵，计算$A^{(k)}$时， $A^{(k)}(i,j)=min{A^{(k-1)}(i,j),A^{(k-1)}(i,k)+A^{(k-1)}(k,j)}$。<br>  &emsp;&emsp;技巧：计算$A^{(k)}$的技巧。第$k$行、第$k$列、对角线的元素保持不变，对其余元素，考查$A(i,j)$与$A(i,k)+A(k,j)$（第 $k$ 列 $i$ 行元素加上第 $k$ 行 $j$ 列元素），如果后者更小则替换$A(i,j)$，同时修改路径。</p></li></ul><h2 id="串匹配KMP算法"><a href="#串匹配KMP算法" class="headerlink" title="串匹配KMP算法"></a>串匹配KMP算法</h2><blockquote><p>参考博文 <a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html</a></p></blockquote><h2 id="五大算法思想"><a href="#五大算法思想" class="headerlink" title="五大算法思想"></a>五大算法思想</h2><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p> &emsp;&emsp;例：背包问题，均分纸牌，最大整数  </p><blockquote><p>参考博文 <a href="https://blog.csdn.net/qq_32400847/article/details/51336300" target="_blank" rel="noopener">https://blog.csdn.net/qq_32400847/article/details/51336300</a></p></blockquote><h3 id="动态规划算法"><a href="#动态规划算法" class="headerlink" title="动态规划算法"></a>动态规划算法</h3><p>&emsp;&emsp;例：0-1背包问题，钢条切割问题  </p><blockquote><p>参考博文 <a href="https://blog.csdn.net/qq_32400847/article/details/51148917" target="_blank" rel="noopener">https://blog.csdn.net/qq_32400847/article/details/51148917</a></p></blockquote><h3 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h3><p>&emsp;&emsp;例：棋盘覆盖、找出伪币、求最值  </p><blockquote><p>参考博文 <a href="https://blog.csdn.net/qq_32400847/article/details/51029121" target="_blank" rel="noopener">https://blog.csdn.net/qq_32400847/article/details/51029121</a></p></blockquote><h3 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h3><p>&emsp;&emsp;例：0-背包问题、旅行商问题、八皇后问题  </p><blockquote><p>参考博文 <a href="https://blog.csdn.net/qq_32400847/article/details/51474105" target="_blank" rel="noopener">https://blog.csdn.net/qq_32400847/article/details/51474105</a></p></blockquote><h3 id="分支限界算法"><a href="#分支限界算法" class="headerlink" title="分支限界算法"></a>分支限界算法</h3><p>&emsp;&emsp;例：装载问题，旅行售货员问题  </p><blockquote><p>参考博文 <a href="https://blog.csdn.net/qq_32400847/article/details/51813606" target="_blank" rel="noopener">https://blog.csdn.net/qq_32400847/article/details/51813606</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;笔经面经归纳汇总：算法&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="笔经面经" scheme="http://zhangchong.xin/categories/%E7%AC%94%E7%BB%8F%E9%9D%A2%E7%BB%8F/"/>
    
    
      <category term="Java" scheme="http://zhangchong.xin/tags/Java/"/>
    
      <category term="校招" scheme="http://zhangchong.xin/tags/%E6%A0%A1%E6%8B%9B/"/>
    
  </entry>
  
  <entry>
    <title>Mac IDEA常用快捷键</title>
    <link href="http://zhangchong.xin/2018/06/06/Mac%20IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://zhangchong.xin/2018/06/06/Mac IDEA常用快捷键/</id>
    <published>2018-06-06T07:01:09.000Z</published>
    <updated>2019-03-10T07:36:33.710Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Mac版本IDEA最常用的快捷键归纳</p></blockquote><a id="more"></a><h1 id="Mac-IDEA常用快捷键"><a href="#Mac-IDEA常用快捷键" class="headerlink" title="Mac IDEA常用快捷键"></a>Mac IDEA常用快捷键</h1><table><thead><tr><th style="text-align:center">快捷键</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">command + option + Space</td><td>智能提示</td></tr><tr><td style="text-align:center">command + option + B</td><td>跳转至实现处</td></tr><tr><td style="text-align:center">command + option + L</td><td>格式化代码</td></tr><tr><td style="text-align:center">command + option + T</td><td>建立包围代码块try/catch if/else等</td></tr><tr><td style="text-align:center">command + option + V</td><td>补全变量</td></tr><tr><td style="text-align:center">command + option + ⬅️/➡️</td><td>跳转到前/后面编辑处</td></tr><tr><td style="text-align:center">command + shift + F</td><td>全局查找</td></tr><tr><td style="text-align:center">command + shift + O</td><td>优化导包</td></tr><tr><td style="text-align:center">command + shift + ⬆️/⬇️</td><td>上/下移动代码</td></tr><tr><td style="text-align:center">command + D</td><td>复制一行到下行</td></tr><tr><td style="text-align:center">command + F</td><td>当前文件查找</td></tr><tr><td style="text-align:center">command + H</td><td>显示层次结构</td></tr><tr><td style="text-align:center">command + L</td><td>跳转到指定行</td></tr><tr><td style="text-align:center">command + P</td><td>显示方法参数信息</td></tr><tr><td style="text-align:center">command + X</td><td>选中全部</td></tr><tr><td style="text-align:center">command + 1</td><td>打开Project视图</td></tr><tr><td style="text-align:center">command + shift + ➕/➖</td><td>展开/折叠所有代码</td></tr><tr><td style="text-align:center">shift + shift</td><td>查找类</td></tr><tr><td style="text-align:center">option + Enter</td><td>快捷修复</td></tr><tr><td style="text-align:center">option + ⬆️/⬇️</td><td>连续选中代码</td></tr><tr><td style="text-align:center">control + ⬆️/⬇️</td><td>方法间移动</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Mac版本IDEA最常用的快捷键归纳&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="开发工具" scheme="http://zhangchong.xin/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Java" scheme="http://zhangchong.xin/tags/Java/"/>
    
      <category term="IDEA" scheme="http://zhangchong.xin/tags/IDEA/"/>
    
      <category term="Mac" scheme="http://zhangchong.xin/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Mac Book Pro常用快捷键</title>
    <link href="http://zhangchong.xin/2018/06/03/Mac%20Book%20Pro%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://zhangchong.xin/2018/06/03/Mac Book Pro常用快捷键/</id>
    <published>2018-06-03T04:51:14.000Z</published>
    <updated>2019-03-10T07:30:31.405Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Mac Book Pro笔记本常用的快捷键汇总</p></blockquote><a id="more"></a><h1 id="Mac-Book-Pro常用快捷键"><a href="#Mac-Book-Pro常用快捷键" class="headerlink" title="Mac Book Pro常用快捷键"></a>Mac Book Pro常用快捷键</h1><table><thead><tr><th style="text-align:center">快捷键</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">command + control + F</td><td>窗口最大化</td></tr><tr><td style="text-align:center">command (+ option) + M</td><td>(所有)窗口最小化</td></tr><tr><td style="text-align:center">command (+ option) + W</td><td>关闭(所有)窗口</td></tr><tr><td style="text-align:center">command + Q</td><td>退出应用</td></tr><tr><td style="text-align:center">command + shift + C</td><td>打开我的电脑</td></tr><tr><td style="text-align:center">(command +) F3</td><td>显示(桌面)调度中心</td></tr><tr><td style="text-align:center">command + A</td><td>选中全部</td></tr><tr><td style="text-align:center">command + S</td><td>保存</td></tr><tr><td style="text-align:center">command (+ shift) + Z</td><td>撤销(重做)</td></tr><tr><td style="text-align:center">command + X</td><td>剪切</td></tr><tr><td style="text-align:center">command + C</td><td>复制</td></tr><tr><td style="text-align:center">command + V</td><td>粘贴</td></tr><tr><td style="text-align:center">command + shift + option + V</td><td>无格式粘贴</td></tr><tr><td style="text-align:center">command + shift + .</td><td>显示隐藏文件</td></tr><tr><td style="text-align:center">command + ⬅️</td><td>当行开头</td></tr><tr><td style="text-align:center">command + ➡️</td><td>当行结尾</td></tr><tr><td style="text-align:center">command + ⬆️</td><td>文稿开头</td></tr><tr><td style="text-align:center">command + ⬇️</td><td>文稿结尾</td></tr><tr><td style="text-align:center">control + shift + off</td><td>睡眠</td></tr><tr><td style="text-align:center">control + space</td><td>切换输入法</td></tr><tr><td style="text-align:center">三指上滑/四指展开</td><td>调度中心/显示桌面</td></tr><tr><td style="text-align:center">command + shift + A</td><td>企业微信截图</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Mac Book Pro笔记本常用的快捷键汇总&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="开发工具" scheme="http://zhangchong.xin/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Mac" scheme="http://zhangchong.xin/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>IDEA快捷键Windows vs Mac</title>
    <link href="http://zhangchong.xin/2018/06/03/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AEWindows%20vs%20Mac/"/>
    <id>http://zhangchong.xin/2018/06/03/IDEA快捷键Windows vs Mac/</id>
    <published>2018-06-03T04:38:03.000Z</published>
    <updated>2019-03-10T08:41:07.565Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>IDEA快捷键Windows版本和Mac版本</p></blockquote><a id="more"></a><h1 id="IDEA快捷键Windows-vs-Mac"><a href="#IDEA快捷键Windows-vs-Mac" class="headerlink" title="IDEA快捷键Windows vs Mac"></a>IDEA快捷键Windows vs Mac</h1><h2 id="Mac-键盘符号说明"><a href="#Mac-键盘符号说明" class="headerlink" title="Mac 键盘符号说明"></a>Mac 键盘符号说明</h2><ul><li><code>⌘</code> == <code>Command</code></li><li><code>⇧</code> == <code>Shift</code></li><li><code>⇪</code> == <code>Caps Lock</code></li><li><code>⌥</code> == <code>Option</code></li><li><code>⌃</code> == <code>Control</code></li><li><code>↩</code> == <code>Return/Enter</code></li><li><code>⌫</code> == <code>Delete</code></li><li><code>⌦</code> == <code>向前删除键（Fn+Delete）</code></li><li><code>↑</code> == <code>上箭头</code></li><li><code>↓</code> == <code>下箭头</code></li><li><code>←</code> == <code>左箭头</code></li><li><code>→</code> == <code>右箭头</code></li><li><code>Page Up</code> == <code>Fn +↑</code></li><li><code>Page Down</code> == <code>Fn +↓</code></li><li><code>Home</code> == <code>Fn + ←</code></li><li><code>End</code> == <code>Fn + →</code></li><li><code>⇥</code> == <code>右制表符（Tab键）</code></li><li><code>⇤</code> == <code>左制表符（Shift+Tab）</code></li><li><code>⎋</code> == <code>Escape (Esc)</code></li><li><code>⏏</code> == <code>电源开关键</code></li></ul><h2 id="Ctrl"><a href="#Ctrl" class="headerlink" title="Ctrl"></a>Ctrl</h2><table><thead><tr><th style="text-align:center">Win 快捷键</th><th style="text-align:center">Mac 快捷键</th><th style="text-align:center">介绍</th></tr></thead><tbody><tr><td style="text-align:center">Ctrl + F</td><td style="text-align:center">Command + F</td><td style="text-align:center">在当前文件进行文本查找</td></tr><tr><td style="text-align:center">Ctrl + R</td><td style="text-align:center">Command + R</td><td style="text-align:center">在当前文件进行文本替换</td></tr><tr><td style="text-align:center">Ctrl + Z</td><td style="text-align:center">Command + Z</td><td style="text-align:center">撤销</td></tr><tr><td style="text-align:center">Ctrl + Y</td><td style="text-align:center">Command + Delete</td><td style="text-align:center">删除光标所在行 或 删除选中的行</td></tr><tr><td style="text-align:center">Ctrl + D</td><td style="text-align:center">Command + D</td><td style="text-align:center">复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面</td></tr><tr><td style="text-align:center">Ctrl + W</td><td style="text-align:center">Option + 方向键上</td><td style="text-align:center">递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围</td></tr><tr><td style="text-align:center">Ctrl + E</td><td style="text-align:center">Command + E</td><td style="text-align:center">显示最近打开的文件记录列表</td></tr><tr><td style="text-align:center">Ctrl + N</td><td style="text-align:center">Command + O</td><td style="text-align:center">根据输入的 类名 查找类文件</td></tr><tr><td style="text-align:center">Ctrl + J</td><td style="text-align:center">Command + J</td><td style="text-align:center">插入自定义动态代码模板</td></tr><tr><td style="text-align:center">Ctrl + P</td><td style="text-align:center">Command + P</td><td style="text-align:center">方法参数提示显示</td></tr><tr><td style="text-align:center">Ctrl + U</td><td style="text-align:center">Command + U</td><td style="text-align:center">前往当前光标所在的方法的父类的方法 / 接口定义</td></tr><tr><td style="text-align:center">Ctrl + B</td><td style="text-align:center">Command + B</td><td style="text-align:center">进入光标所在的方法/变量的接口或是定义处，等效于 <code>Ctrl + 左键单击</code></td></tr><tr><td style="text-align:center">Ctrl + /</td><td style="text-align:center">Command + /</td><td style="text-align:center">注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号</td></tr><tr><td style="text-align:center">Ctrl + F1</td><td style="text-align:center">Command + F1</td><td style="text-align:center">在光标所在的错误代码处显示错误信息</td></tr><tr><td style="text-align:center">Ctrl + F11</td><td style="text-align:center">Option + F3</td><td style="text-align:center">选中文件 / 文件夹，使用助记符设定 / 取消书签</td></tr><tr><td style="text-align:center">Ctrl + Space</td><td style="text-align:center">Control + Space</td><td style="text-align:center">基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 <code>Ctrl + 逗号</code></td></tr><tr><td style="text-align:center">Ctrl + Delete</td><td style="text-align:center">Option + Fn + Delete</td><td style="text-align:center">删除光标后面的单词或是中文句</td></tr><tr><td style="text-align:center">Ctrl + BackSpace</td><td style="text-align:center">Option + Delete</td><td style="text-align:center">删除光标前面的单词或是中文句</td></tr><tr><td style="text-align:center">Ctrl + 1,2,3…9</td><td style="text-align:center">Control + 1,2,3…9</td><td style="text-align:center">定位到对应数值的书签位置</td></tr><tr><td style="text-align:center">Ctrl + 加号</td><td style="text-align:center">Command + 加号</td><td style="text-align:center">展开代码</td></tr><tr><td style="text-align:center">Ctrl + 减号</td><td style="text-align:center">Command + 减号</td><td style="text-align:center">折叠代码</td></tr><tr><td style="text-align:center">Ctrl + 左键单击</td><td style="text-align:center">Control + 左键单击</td><td style="text-align:center">在打开的文件标题上，弹出该文件路径</td></tr><tr><td style="text-align:center">Ctrl + 左方向键</td><td style="text-align:center">Option + 左方向键</td><td style="text-align:center">光标跳转到当前单词 / 中文句的左侧开头位置</td></tr><tr><td style="text-align:center">Ctrl + 右方向键</td><td style="text-align:center">Option + 右方向键</td><td style="text-align:center">光标跳转到当前单词 / 中文句的右侧开头位置</td></tr><tr><td style="text-align:center">Ctrl + 前方向键</td><td style="text-align:center">预设中没有该快捷键</td><td style="text-align:center">等效于鼠标滚轮向前效果</td></tr><tr><td style="text-align:center">Ctrl + 后方向键</td><td style="text-align:center">预设中没有该快捷键</td><td style="text-align:center">等效于鼠标滚轮向后效果</td></tr></tbody></table><h2 id="Alt"><a href="#Alt" class="headerlink" title="Alt"></a>Alt</h2><table><thead><tr><th style="text-align:center">Win 快捷键</th><th style="text-align:center">Mac 快捷键</th><th style="text-align:center">介绍</th></tr></thead><tbody><tr><td style="text-align:center">Alt + `</td><td style="text-align:center">Control + V</td><td style="text-align:center">显示版本控制常用操作菜单弹出层</td></tr><tr><td style="text-align:center">Alt + F1</td><td style="text-align:center">Option + F1</td><td style="text-align:center">显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择</td></tr><tr><td style="text-align:center">Alt + F7</td><td style="text-align:center">Option + F7</td><td style="text-align:center">查询所选对象/变量被引用</td></tr><tr><td style="text-align:center">Alt + Enter</td><td style="text-align:center">Option + Enter</td><td style="text-align:center">IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同</td></tr><tr><td style="text-align:center">Alt + Insert</td><td style="text-align:center">Command + N</td><td style="text-align:center">代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等</td></tr><tr><td style="text-align:center">Alt + 左方向键</td><td style="text-align:center">Control + 左方向键</td><td style="text-align:center">切换当前已打开的窗口中的子视图，比如Debug窗口中有Output、Debugger等子视图，用此快捷键就可以在子视图中切换</td></tr><tr><td style="text-align:center">Alt + 右方向键</td><td style="text-align:center">Control + 右方向键</td><td style="text-align:center">切换当前已打开的窗口中的子视图，比如Debug窗口中有Output、Debugger等子视图，用此快捷键就可以在子视图中切换</td></tr><tr><td style="text-align:center">Alt + 前方向键</td><td style="text-align:center">Control + 前方向键</td><td style="text-align:center">当前光标跳转到当前文件的前一个方法名位置</td></tr><tr><td style="text-align:center">Alt + 后方向键</td><td style="text-align:center">Control + 后方向键</td><td style="text-align:center">当前光标跳转到当前文件的后一个方法名位置</td></tr><tr><td style="text-align:center">Alt + 1,2,3…9</td><td style="text-align:center">Command + 1,2,3…9</td><td style="text-align:center">显示对应数值的选项卡，其中 1 是 Project 用得最多</td></tr></tbody></table><h2 id="Shift"><a href="#Shift" class="headerlink" title="Shift"></a>Shift</h2><table><thead><tr><th style="text-align:center">Win 快捷键</th><th style="text-align:center">Mac 快捷键</th><th style="text-align:center">介绍</th></tr></thead><tbody><tr><td style="text-align:center">Shift + F11</td><td style="text-align:center">Command + F3</td><td style="text-align:center">弹出书签显示层</td></tr><tr><td style="text-align:center">Shift + Tab</td><td style="text-align:center">Shift + Tab</td><td style="text-align:center">取消缩进</td></tr><tr><td style="text-align:center">Shift + Enter</td><td style="text-align:center">Shift + Enter</td><td style="text-align:center">开始新一行。光标所在行下空出一行，光标定位到新行位置</td></tr><tr><td style="text-align:center">Shift + 左键单击</td><td style="text-align:center">Shift + 左键单击</td><td style="text-align:center">在打开的文件名上按此快捷键，可以关闭当前打开文件</td></tr></tbody></table><h2 id="Ctrl-Alt"><a href="#Ctrl-Alt" class="headerlink" title="Ctrl + Alt"></a>Ctrl + Alt</h2><table><thead><tr><th style="text-align:center">Win 快捷键</th><th style="text-align:center">Mac 快捷键</th><th style="text-align:center">介绍</th></tr></thead><tbody><tr><td style="text-align:center">Ctrl + Alt + L</td><td style="text-align:center">Command + Option + L</td><td style="text-align:center">格式化代码，可以对当前文件和整个包目录使用</td></tr><tr><td style="text-align:center">Ctrl + Alt + O</td><td style="text-align:center">Control + Option + O</td><td style="text-align:center">优化导入的类，可以对当前文件和整个包目录使用</td></tr><tr><td style="text-align:center">Ctrl + Alt + T</td><td style="text-align:center">Command + Option + T</td><td style="text-align:center">对选中的代码弹出环绕选项弹出层</td></tr><tr><td style="text-align:center">Ctrl + Alt + S</td><td style="text-align:center">Command + 逗号</td><td style="text-align:center">打开 IntelliJ IDEA 系统设置</td></tr><tr><td style="text-align:center">Ctrl + Alt + Enter</td><td style="text-align:center">Command + Option + Enter</td><td style="text-align:center">光标所在行上空出一行，光标定位到新行</td></tr><tr><td style="text-align:center">Ctrl + Alt + 左方向键</td><td style="text-align:center">Command + Option + 左方向键</td><td style="text-align:center">退回到上一个操作的地方</td></tr><tr><td style="text-align:center">Ctrl + Alt + 右方向键</td><td style="text-align:center">Command + Option + 右方向键</td><td style="text-align:center">前进到上一个操作的地方</td></tr></tbody></table><h2 id="Ctrl-Shift"><a href="#Ctrl-Shift" class="headerlink" title="Ctrl + Shift"></a>Ctrl + Shift</h2><table><thead><tr><th style="text-align:center">Win 快捷键</th><th style="text-align:center">Mac 快捷键</th><th style="text-align:center">介绍</th></tr></thead><tbody><tr><td style="text-align:center">Ctrl + Shift + F</td><td style="text-align:center">Command + Shift + F</td><td style="text-align:center">根据输入内容查找整个项目 或 指定目录内文件</td></tr><tr><td style="text-align:center">Ctrl + Shift + R</td><td style="text-align:center">Command + Shift + F</td><td style="text-align:center">根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件</td></tr><tr><td style="text-align:center">Ctrl + Shift + J</td><td style="text-align:center">Control + Shift + J</td><td style="text-align:center">自动将下一行合并到当前行末尾</td></tr><tr><td style="text-align:center">Ctrl + Shift + Z</td><td style="text-align:center">Command + Shift + Z</td><td style="text-align:center">取消撤销</td></tr><tr><td style="text-align:center">Ctrl + Shift + W</td><td style="text-align:center">Option + 方向键下</td><td style="text-align:center">递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围</td></tr><tr><td style="text-align:center">Ctrl + Shift + N</td><td style="text-align:center">Command + Shift + O</td><td style="text-align:center">通过文件名定位 / 打开文件 / 目录，打开目录需要在输入的内容后面多加一个正斜杠</td></tr><tr><td style="text-align:center">Ctrl + Shift + U</td><td style="text-align:center">Command + Shift + U</td><td style="text-align:center">对选中的代码进行大 / 小写轮流转换</td></tr><tr><td style="text-align:center">Ctrl + Shift + T</td><td style="text-align:center">Command + Shift + T</td><td style="text-align:center">对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择</td></tr><tr><td style="text-align:center">Ctrl + Shift + C</td><td style="text-align:center">Command + Shift + C</td><td style="text-align:center">复制当前文件磁盘路径到剪贴板</td></tr><tr><td style="text-align:center">Ctrl + Shift + B</td><td style="text-align:center">Control + Shift + B</td><td style="text-align:center">跳转到类型声明处</td></tr><tr><td style="text-align:center">Ctrl + Shift + /</td><td style="text-align:center">Command + Option + /</td><td style="text-align:center">代码块注释</td></tr><tr><td style="text-align:center">Ctrl + Shift + [</td><td style="text-align:center">Command + Shift + [</td><td style="text-align:center">选中从光标所在位置到它的顶部中括号位置</td></tr><tr><td style="text-align:center">Ctrl + Shift + ]</td><td style="text-align:center">Command + Shift + ]</td><td style="text-align:center">选中从光标所在位置到它的底部中括号位置</td></tr><tr><td style="text-align:center">Ctrl + Shift + 加号</td><td style="text-align:center">Command + Shift + 加号</td><td style="text-align:center">展开所有代码</td></tr><tr><td style="text-align:center">Ctrl + Shift + 减号</td><td style="text-align:center">Command + Shift + 减号</td><td style="text-align:center">折叠所有代码</td></tr><tr><td style="text-align:center">Ctrl + Shift + F7</td><td style="text-align:center">Command + Shift + F7</td><td style="text-align:center">高亮显示所有该选中文本，按Esc高亮消失</td></tr><tr><td style="text-align:center">Ctrl + Shift + F12</td><td style="text-align:center">Command + Shift + F12</td><td style="text-align:center">编辑器最大化</td></tr><tr><td style="text-align:center">Ctrl + Shift + Enter</td><td style="text-align:center">Command + Shift + Enter</td><td style="text-align:center">自动结束代码，行末自动添加分号</td></tr><tr><td style="text-align:center">Ctrl + Shift + Backspace</td><td style="text-align:center">Ctrl + Shift + Backspace</td><td style="text-align:center">退回到上次修改的地方</td></tr><tr><td style="text-align:center">Ctrl + Shift + 1,2,3…9</td><td style="text-align:center">Control + Shift + 1,2,3…9</td><td style="text-align:center">快速添加指定数值的书签</td></tr><tr><td style="text-align:center">Ctrl + Shift + 左键单击</td><td style="text-align:center">Command + Shift + 左键单击</td><td style="text-align:center">把光标放在某个类变量上，按此快捷键可以直接定位到该类中</td></tr><tr><td style="text-align:center">Ctrl + Shift + 左方向键</td><td style="text-align:center">Option + Shift + 左方向键</td><td style="text-align:center">在代码文件上，光标跳转到当前单词 / 中文句的左侧开头位置，同时选中该单词 / 中文句</td></tr><tr><td style="text-align:center">Ctrl + Shift + 右方向键</td><td style="text-align:center">Option + Shift + 右方向键</td><td style="text-align:center">在代码文件上，光标跳转到当前单词 / 中文句的右侧开头位置，同时选中该单词 / 中文句</td></tr><tr><td style="text-align:center">Ctrl + Shift + 前方向键</td><td style="text-align:center">Command + Shift + 前方向键</td><td style="text-align:center">光标放在方法名上，将方法移动到上一个方法前面，调整方法排序</td></tr><tr><td style="text-align:center">Ctrl + Shift + 后方向键</td><td style="text-align:center">Command + Shift + 后方向键</td><td style="text-align:center">光标放在方法名上，将方法移动到下一个方法前面，调整方法排序</td></tr></tbody></table><h2 id="Alt-Shift"><a href="#Alt-Shift" class="headerlink" title="Alt + Shift"></a>Alt + Shift</h2><table><thead><tr><th style="text-align:center">Win 快捷键</th><th style="text-align:center">Mac</th><th style="text-align:center">快捷键</th><th>介绍</th></tr></thead><tbody><tr><td style="text-align:center">Alt + Shift + N</td><td style="text-align:center">Option + Shift + B</td><td style="text-align:center">选择 / 添加 task</td></tr><tr><td style="text-align:center">Alt + Shift + 左键双击</td><td style="text-align:center">Option + Shift + 左键双击</td><td style="text-align:center">选择被双击的单词 / 中文句，按住不放，可以同时选择其他单词 / 中文句</td></tr><tr><td style="text-align:center">Alt + Shift + 前方向键</td><td style="text-align:center">Option + Shift + 前方向键</td><td style="text-align:center">移动光标所在行向上移动</td></tr><tr><td style="text-align:center">Alt + Shift + 后方向键</td><td style="text-align:center">Option + Shift + 后方向键</td><td style="text-align:center">移动光标所在行向下移动</td></tr></tbody></table><h2 id="Ctrl-Shift-Alt"><a href="#Ctrl-Shift-Alt" class="headerlink" title="Ctrl + Shift + Alt"></a>Ctrl + Shift + Alt</h2><table><thead><tr><th style="text-align:center">Win 快捷键</th><th style="text-align:center">Mac 快捷键</th><th style="text-align:center">介绍</th></tr></thead><tbody><tr><td style="text-align:center">Ctrl + Shift + Alt + V</td><td style="text-align:center">Command + Shift + Option + V</td><td style="text-align:center">无格式黏贴</td></tr><tr><td style="text-align:center">Ctrl + Shift + Alt + S</td><td style="text-align:center">Command + ;</td><td style="text-align:center">打开当前项目设置</td></tr></tbody></table><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><table><thead><tr><th style="text-align:center">Win 快捷键</th><th style="text-align:center">Mac 快捷键</th><th style="text-align:center">介绍</th></tr></thead><tbody><tr><td style="text-align:center">F2</td><td style="text-align:center">F2</td><td style="text-align:center">跳转到下一个高亮错误 或 警告位置</td></tr><tr><td style="text-align:center">F4</td><td style="text-align:center">F4</td><td style="text-align:center">编辑源</td></tr><tr><td style="text-align:center">F11</td><td style="text-align:center">F3</td><td style="text-align:center">添加书签</td></tr><tr><td style="text-align:center">F12</td><td style="text-align:center">F12</td><td style="text-align:center">回到前一个工具窗口</td></tr><tr><td style="text-align:center">Tab</td><td style="text-align:center">Tab</td><td style="text-align:center">缩进</td></tr><tr><td style="text-align:center">ESC</td><td style="text-align:center">ESC</td><td style="text-align:center">从工具窗口进入代码文件窗口</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;IDEA快捷键Windows版本和Mac版本&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="开发工具" scheme="http://zhangchong.xin/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="IDEA" scheme="http://zhangchong.xin/tags/IDEA/"/>
    
      <category term="Mac" scheme="http://zhangchong.xin/tags/Mac/"/>
    
      <category term="Windows" scheme="http://zhangchong.xin/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>美团Java实习面试</title>
    <link href="http://zhangchong.xin/2018/06/02/%E7%BE%8E%E5%9B%A2Java%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95/"/>
    <id>http://zhangchong.xin/2018/06/02/美团Java实习面试/</id>
    <published>2018-06-02T11:42:24.000Z</published>
    <updated>2019-03-10T07:28:43.858Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2018年5月9日 11:00 ，接到美团Java实习生电话面试，面试进行了50分钟，记录如下：</p></blockquote><a id="more"></a><h1 id="美团Java实习面试"><a href="#美团Java实习面试" class="headerlink" title="美团Java实习面试"></a>美团Java实习面试</h1><h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><h2 id="Redis缓存更新策略"><a href="#Redis缓存更新策略" class="headerlink" title="Redis缓存更新策略"></a>Redis缓存更新策略</h2><h2 id="RabbbitMQ削峰实现"><a href="#RabbbitMQ削峰实现" class="headerlink" title="RabbbitMQ削峰实现"></a>RabbbitMQ削峰实现</h2><h2 id="Java异常机制（Throwable能否catch）"><a href="#Java异常机制（Throwable能否catch）" class="headerlink" title="Java异常机制（Throwable能否catch）"></a>Java异常机制（Throwable能否catch）</h2><h2 id="HashMap、ConcurrentHashMap（几段）"><a href="#HashMap、ConcurrentHashMap（几段）" class="headerlink" title="HashMap、ConcurrentHashMap（几段）"></a>HashMap、ConcurrentHashMap（几段）</h2><h2 id="访问一个网页全过程"><a href="#访问一个网页全过程" class="headerlink" title="访问一个网页全过程"></a>访问一个网页全过程</h2><h2 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h2><h2 id="sleep-和wait"><a href="#sleep-和wait" class="headerlink" title="sleep()和wait()"></a>sleep()和wait()</h2><h2 id="solr"><a href="#solr" class="headerlink" title="solr"></a>solr</h2><h2 id="http几种方法的区别，header里面的内容"><a href="#http几种方法的区别，header里面的内容" class="headerlink" title="http几种方法的区别，header里面的内容"></a>http几种方法的区别，header里面的内容</h2><h2 id="查询所有科目成绩都大于80的学生-SQL-语句"><a href="#查询所有科目成绩都大于80的学生-SQL-语句" class="headerlink" title="查询所有科目成绩都大于80的学生 SQL 语句"></a>查询所有科目成绩都大于80的学生 SQL 语句</h2><h2 id="设计唯一且自增的-int-型-ID"><a href="#设计唯一且自增的-int-型-ID" class="headerlink" title="设计唯一且自增的 int 型 ID"></a>设计唯一且自增的 int 型 ID</h2><h2 id="Integer-缓存"><a href="#Integer-缓存" class="headerlink" title="Integer  缓存"></a>Integer  缓存</h2><h2 id="堆结构"><a href="#堆结构" class="headerlink" title="堆结构"></a>堆结构</h2><h2 id="static-修饰的用法，静态类使用场景"><a href="#static-修饰的用法，静态类使用场景" class="headerlink" title="static 修饰的用法，静态类使用场景"></a>static 修饰的用法，静态类使用场景</h2><h2 id="Java-创建对象的几种方式：new-clone-反射-反序列化"><a href="#Java-创建对象的几种方式：new-clone-反射-反序列化" class="headerlink" title="Java 创建对象的几种方式：new clone 反射 反序列化"></a>Java 创建对象的几种方式：new clone 反射 反序列化</h2><h2 id="有什么问题要咨询"><a href="#有什么问题要咨询" class="headerlink" title="有什么问题要咨询"></a>有什么问题要咨询</h2>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;2018年5月9日 11:00 ，接到美团Java实习生电话面试，面试进行了50分钟，记录如下：&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="笔经面经" scheme="http://zhangchong.xin/categories/%E7%AC%94%E7%BB%8F%E9%9D%A2%E7%BB%8F/"/>
    
    
      <category term="Java" scheme="http://zhangchong.xin/tags/Java/"/>
    
      <category term="美团" scheme="http://zhangchong.xin/tags/%E7%BE%8E%E5%9B%A2/"/>
    
  </entry>
  
  <entry>
    <title>蘑菇街Java实习面试</title>
    <link href="http://zhangchong.xin/2018/05/29/%E8%98%91%E8%8F%87%E8%A1%97Java%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95/"/>
    <id>http://zhangchong.xin/2018/05/29/蘑菇街Java实习面试/</id>
    <published>2018-05-29T09:47:38.000Z</published>
    <updated>2019-03-12T11:28:11.237Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2018年4月17日16时20分接到蘑菇街Java实习生电话初面，面试进行了30分钟，记录如下：</p></blockquote><a id="more"></a><h1 id="蘑菇街Java实习面试"><a href="#蘑菇街Java实习面试" class="headerlink" title="蘑菇街Java实习面试"></a>蘑菇街Java实习面试</h1><h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><h2 id="Java-和-C"><a href="#Java-和-C" class="headerlink" title="Java 和 C++"></a>Java 和 C++</h2><table><thead><tr><th style="text-align:center">比较点</th><th style="text-align:center">Java</th><th style="text-align:center">C++</th></tr></thead><tbody><tr><td style="text-align:center">面向对象思想</td><td style="text-align:center">完全对象化</td><td style="text-align:center">可采用非面向对象(兼容C)</td></tr><tr><td style="text-align:center">内存管理机制</td><td style="text-align:center">Java自身管理</td><td style="text-align:center">程序员管理</td></tr><tr><td style="text-align:center">异常机制</td><td style="text-align:center">完善</td><td style="text-align:center">欠缺</td></tr><tr><td style="text-align:center">第三方库</td><td style="text-align:center">丰富(Log、JUnit等等)</td><td style="text-align:center">较少(STL)</td></tr><tr><td style="text-align:center">执行效率</td><td style="text-align:center">慢</td><td style="text-align:center">快</td></tr><tr><td style="text-align:center">操控底层</td><td style="text-align:center">麻烦</td><td style="text-align:center">方便</td></tr></tbody></table><h2 id="访问网页全过程"><a href="#访问网页全过程" class="headerlink" title="访问网页全过程"></a>访问网页全过程</h2><ol><li>输入URL；</li><li>DNS将域名解析成IP地址；</li><li>建立TCP连接；</li><li>OSPF（内部网关协议）决定经过哪些路由器，ARP（地址解析协议）负责求下一个节点地址；</li><li>发送HTTP请求；</li><li>得到响应，展现HTML界面。</li></ol><h2 id="GET-POST-区别"><a href="#GET-POST-区别" class="headerlink" title="GET POST 区别"></a>GET POST 区别</h2><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">描述</th><th style="text-align:center">幂等性</th><th>安全性</th></tr></thead><tbody><tr><td style="text-align:center">POST</td><td style="text-align:center">向指定资源提交数据进行处理请求（例如提交表单或上传文件）</td><td style="text-align:center">否</td><td>否</td></tr><tr><td style="text-align:center">PUT</td><td style="text-align:center">向指定资源位置上传其最新内容</td><td style="text-align:center">是</td><td>否</td></tr><tr><td style="text-align:center">DELETE</td><td style="text-align:center">请求服务器删除所标识的资源</td><td style="text-align:center">是</td><td>否</td></tr><tr><td style="text-align:center">GET</td><td style="text-align:center">向特定的资源发出请求</td><td style="text-align:center">是</td><td>是</td></tr></tbody></table><h2 id="TCP-UDP-HTTP"><a href="#TCP-UDP-HTTP" class="headerlink" title="TCP UDP HTTP"></a>TCP UDP HTTP</h2><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">TCP</th><th style="text-align:center">UDP</th><th style="text-align:center">HTTP</th></tr></thead><tbody><tr><td style="text-align:center">是否连接</td><td style="text-align:center">面向连接</td><td style="text-align:center">面向非连接</td><td style="text-align:center">基于TCP</td></tr><tr><td style="text-align:center">传输可靠性</td><td style="text-align:center">可靠</td><td style="text-align:center">不可靠</td><td style="text-align:center">–</td></tr><tr><td style="text-align:center">应用场合</td><td style="text-align:center">传输大量的数据，对可靠性要求较高的场合</td><td style="text-align:center">传送少量数据、对可靠性要求不高的场景</td><td style="text-align:center">–</td></tr><tr><td style="text-align:center">速度</td><td style="text-align:center">慢</td><td style="text-align:center">快</td><td style="text-align:center">–</td></tr></tbody></table><h2 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h2><ul><li>vim命令：文本编辑</li><li>gcc命令：编译</li><li>ps命令：进程运行情况</li><li>kill命令：停止进程</li><li>atop / htop命令：查看内存使用情况</li></ul><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>&emsp;&emsp;基于C语言开发的一种非关系型数据库，数据放在内存，使用RDB[快照]方式或者AOF[日志]方式持久化。 Redis的优势包括速度、对富数据类型的支持（String、Hash、List、Set、Zset）、原子性操作、通用性。</p><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p>&emsp;&emsp;消息队列中间件是分布式系统中重要的组件，主要主要解决应用耦合、异步消息、流量削锋等问题，具有异步性、可靠性（存储到本地硬盘）、松耦合、分布式的特性。</p><ul><li>主要特点是异步处理</li><li>主要目的是减少请求响应时间、解耦</li><li>主要使用场景是将比较耗时且不需同步返回结果的操作当做消息存入队列</li></ul><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><ul><li>正向代理：隐藏真实的请求客户端，服务端不知道真实的客户端是谁，正向代理服务器会代替客户端向服务器发送请求。正向代理代理的对象是客户端。</li><li>反向代理：隐藏真实的响应服务端，客户端不知道真实的服务端是谁，反向代理服务器会把请求转发到真实的服务器。反向代理代理的对象是服务端。</li></ul><blockquote><p>10086总机就是一种反向代理，客户不知道真正提供服务人的是谁。</p></blockquote><h2 id="Spring-Boot-启动流程（不会）"><a href="#Spring-Boot-启动流程（不会）" class="headerlink" title="Spring Boot 启动流程（不会）"></a>Spring Boot 启动流程（不会）</h2><p>参考博文 <a href="https://www.cnblogs.com/zheting/p/6707035.html" target="_blank" rel="noopener">https://www.cnblogs.com/zheting/p/6707035.html</a><br><img src="https://raw.githubusercontent.com/chung567115/chung567115.github.io/hexo-blog/blog-img/24-1.png" alt="Spring Boot 启动流程"></p><h2 id="自定义starter（不会）"><a href="#自定义starter（不会）" class="headerlink" title="自定义starter（不会）"></a>自定义starter（不会）</h2><p>参考博文 <a href="https://blog.csdn.net/liuchuanhong1/article/details/55057135" target="_blank" rel="noopener">https://blog.csdn.net/liuchuanhong1/article/details/55057135</a></p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>&emsp;&emsp;实现多线程的几种方式</p><ul><li>继承Thread类创建线程</li><li>实现Callable接口创建线程</li><li>实现Runnable接口创建新线程(可用Future返回结果)</li></ul><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>&emsp;&emsp;设计理念是为了减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。作用是提供线程内部的局部变量，这些变量在多线程环境下访问(get/set)时能保证与其它线程里的变量相对独立。打个比方，多人(多个线程)使用自己的交通卡(线程私有变量)乘公交转地铁(两个函数)。</p><blockquote><p>synchronized用于线程间的数据共享，而ThreadLocal则用于线程间的数据隔离。</p></blockquote><h2 id="ThreadLocal-不清空会有什么影响（答得不好）"><a href="#ThreadLocal-不清空会有什么影响（答得不好）" class="headerlink" title="ThreadLocal 不清空会有什么影响（答得不好）"></a>ThreadLocal 不清空会有什么影响（答得不好）</h2><p>&emsp;&emsp;如果使用了线程池，那么即使即使父线程已经结束，子线程依然存在并被池化。这样，线程池中的线程在下一次请求被执行的时候，ThreadLocal 对象的 get() 方法返回的将不是当前线程中设定的变量，因为池中的子线程根本不是当前线程创建的，当前线程设定的 ThreadLocal 变量也就无法传递给线程池中的线程。<br>&emsp;&emsp;因此，必须将外部线程中的 ThreadLocal 变量显式地传递给线程池中的线程，或者每个请求来的时候先 threadLocal.set(null) 。</p><h2 id="ThreadPool"><a href="#ThreadPool" class="headerlink" title="ThreadPool"></a>ThreadPool</h2><p>&emsp;&emsp;使用线程池的优势：</p><ul><li>降低资源消耗：重复利用已创建的线程，降低创建和销毁造成的消耗。</li><li>提高响应速度：任务可以不需要等到线程创建就能立即执行(参考上条)。</li><li>提高管理性：可以进行统一的分配、调优和监控。</li></ul><h2 id="有什么问题要问的"><a href="#有什么问题要问的" class="headerlink" title="有什么问题要问的"></a>有什么问题要问的</h2>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;2018年4月17日16时20分接到蘑菇街Java实习生电话初面，面试进行了30分钟，记录如下：&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="笔经面经" scheme="http://zhangchong.xin/categories/%E7%AC%94%E7%BB%8F%E9%9D%A2%E7%BB%8F/"/>
    
    
      <category term="Java" scheme="http://zhangchong.xin/tags/Java/"/>
    
      <category term="蘑菇街" scheme="http://zhangchong.xin/tags/%E8%98%91%E8%8F%87%E8%A1%97/"/>
    
  </entry>
  
  <entry>
    <title>酷家乐Java实习面试</title>
    <link href="http://zhangchong.xin/2018/05/29/%E9%85%B7%E5%AE%B6%E4%B9%90Java%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95/"/>
    <id>http://zhangchong.xin/2018/05/29/酷家乐Java实习面试/</id>
    <published>2018-05-29T09:47:04.000Z</published>
    <updated>2019-03-10T07:24:28.624Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2018年3月20日15时00分到酷家乐赴约Java实习现场面试，进行了接近2小时，记录如下：</p></blockquote><a id="more"></a><h1 id="酷家乐Java实习面试（40MIN）"><a href="#酷家乐Java实习面试（40MIN）" class="headerlink" title="酷家乐Java实习面试（40MIN）"></a>酷家乐Java实习面试（40MIN）</h1><h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><h3 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h3><h3 id="多线程实现"><a href="#多线程实现" class="headerlink" title="多线程实现"></a>多线程实现</h3><ol><li>继承Thread类创建线程</li><li>实现Callable接口创建线程</li><li>实现Runnable接口创建新线程<h3 id="流量削峰的一种解决方案"><a href="#流量削峰的一种解决方案" class="headerlink" title="流量削峰的一种解决方案"></a>流量削峰的一种解决方案</h3></li></ol><ul><li>MQ推送模式改为定时或者批量拉取模式</li><li>消息接收方实现批量处理等方式<h3 id="介绍Redis"><a href="#介绍Redis" class="headerlink" title="介绍Redis"></a>介绍Redis</h3>&emsp;&emsp;基于C语言开发的一种非关系型数据库，数据放在内存，使用<strong>RDB</strong>[快照]方式或者<strong>AOF</strong>[日志]方式持久化。</li></ul><p>&emsp;&emsp;Redis的优势包括速度、对富数据类型的支持（String、Hash、List、Set、Zset）、原子性操作、通用性。</p><h3 id="Redis使用场景（回答得不好）"><a href="#Redis使用场景（回答得不好）" class="headerlink" title="Redis使用场景（回答得不好）"></a>Redis使用场景（<em>回答得不好</em>）</h3><ul><li>缓存（<strong> 热数据 </strong>）</li><li>共享Session</li><li>队列 / 栈</li><li>位操作（<strong> 大数据处理 </strong>）</li><li>分布式锁与单线程机制（<strong> 秒杀系统 </strong>）</li><li>排行榜 / 计数器（<strong> ZSet ZADD命令 </strong>）</li><li>发布 / 订阅<h3 id="Redis如何保证原子性（不会）"><a href="#Redis如何保证原子性（不会）" class="headerlink" title="Redis如何保证原子性（不会）"></a>Redis如何保证原子性（<em>不会</em>）</h3></li></ul><ol><li>单个操作是原子性的</li><li>多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来<h3 id="介绍对MyBatis的理解"><a href="#介绍对MyBatis的理解" class="headerlink" title="介绍对MyBatis的理解"></a>介绍对MyBatis的理解</h3>&emsp;&emsp;MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集，它可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJO 映射成数据库中的记录。<h3 id="SpringMVC的核心"><a href="#SpringMVC的核心" class="headerlink" title="SpringMVC的核心"></a>SpringMVC的核心</h3></li></ol><ul><li>控制器核心类：DispatcherServlet</li><li>加载配置文件核心类：ContextLoaderListener</li><li>处理url映射核心类：BeanNameUrlHandlerMapping</li><li>处理视图资源核心类：ResourceBundleViewResolver</li><li><p>方法动态调用核心类ParameterMethodNameResolver</p><h3 id="介绍对Spring的理解"><a href="#介绍对Spring的理解" class="headerlink" title="介绍对Spring的理解"></a>介绍对Spring的理解</h3><p>&emsp;&emsp;Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架。</p></li><li><p>IoC：控制反转（Inversion of Control）和依赖注入（Dependecy Injection）广义上讲是同一个概念，具体的讲：在Spring中创建被调用者的工作不再由调用者来完成，因此称为控制反转。创建被调用者的工作由Spring来完成，然后注入调用者，因此也称为依赖注入。</p></li><li><p>AOP：面向切面编程（AOP）在Spring中主要表现为两个方面 1. 面向切面编程提供声明式事务管理 。2. Spring支持用户自定义的切面。</p><h3 id="Java-8新特性（答得不好）"><a href="#Java-8新特性（答得不好）" class="headerlink" title="Java 8新特性（答得不好）"></a>Java 8新特性（答得不好）</h3><p>&emsp;&emsp;主要有以下几个新特性：</p></li><li><p><strong>默认方法</strong>：在接口里面有了一个实现的方法</p></li><li>Lambda 表达式：Lambda允许把函数作为一个方法的参数</li><li>Stream API：把真正的函数式编程风格引入到Java中</li><li>Date Time API：加强对日期与时间的处理</li><li>Optional 类：Optional 类已成为 Java 8 类库的一部分，用来解决空指针异常</li><li>方法引用：可以直接引用已有Java类或对象的方法或构造器</li><li><p>新编译工具：Nashorn引擎（一个新的JavaScript引擎）、 类依赖分析器</p><h3 id="λ表达式的理解"><a href="#λ表达式的理解" class="headerlink" title="λ表达式的理解"></a>λ表达式的理解</h3><p>&emsp;&emsp;流式数据处理</p><h3 id="对RESTful的理解"><a href="#对RESTful的理解" class="headerlink" title="对RESTful的理解"></a>对RESTful的理解</h3><p>&emsp;&emsp;<strong>URL定位资源，HTTP动词描述操作</strong></p></li><li><p>GET    用来获取资源</p></li><li>POST  用来新建 / 更新资源</li><li>PUT    用来更新资源</li><li>DELETE  用来删除资源<h3 id="对微服务的了解"><a href="#对微服务的了解" class="headerlink" title="对微服务的了解"></a>对微服务的了解</h3>&emsp;&emsp;微服务架构风格是一种使用一套小服务来开发单个应用的方式，每个服务运行在自己的进程中，并使用轻量级机制通信（通常是HTTP API），这些服务能够通过自动化部署机制来独立部署、可以使用不同的编程语言实现、可以使用不同的数据存储技术，并保持最低限度的集中式管理。<h3 id="DiskLruCache海量图片缓存"><a href="#DiskLruCache海量图片缓存" class="headerlink" title="DiskLruCache海量图片缓存"></a>DiskLruCache海量图片缓存</h3>&emsp;&emsp;<strong>三级缓存</strong>:内存LruCache + 磁盘DiskLruCache + 网络Retrofit 2<blockquote><p>这是面试官问到本人以前做过的Android项目</p></blockquote></li></ul><h3 id="遇到过什么技术难题，最终如何解决的"><a href="#遇到过什么技术难题，最终如何解决的" class="headerlink" title="遇到过什么技术难题，最终如何解决的"></a>遇到过什么技术难题，最终如何解决的</h3><h3 id="有什么需要问的"><a href="#有什么需要问的" class="headerlink" title="有什么需要问的"></a>有什么需要问的</h3><hr><h2 id="笔试（1H，共4道题，忘了一道）"><a href="#笔试（1H，共4道题，忘了一道）" class="headerlink" title="笔试（1H，共4道题，忘了一道）"></a>笔试（1H，共4道题，忘了一道）</h2><h3 id="给定一元素可重复的有序数组和一个值，找出数组内该值首次出现和最后出现的数组下标"><a href="#给定一元素可重复的有序数组和一个值，找出数组内该值首次出现和最后出现的数组下标" class="headerlink" title="给定一元素可重复的有序数组和一个值，找出数组内该值首次出现和最后出现的数组下标"></a>给定一元素可重复的有序数组和一个值，找出数组内该值首次出现和最后出现的数组下标</h3><ol><li>不限时间复杂度</li><li>时间复杂度 &lt; O（N）<blockquote><p>可用改进的二分法解答：若当前单位的左右值均不等于给定值时命中。</p></blockquote></li></ol><h3 id="给定一单向列表头部，判断队列有无环路"><a href="#给定一单向列表头部，判断队列有无环路" class="headerlink" title="给定一单向列表头部，判断队列有无环路"></a>给定一单向列表头部，判断队列有无环路</h3><ol><li>不限空间复杂度</li><li>空间复杂度  &lt; O（N）<blockquote><p>可用双指针追逐法解答：步长分别为 k 和 k+1，某一步两指针相遇则有环路。</p></blockquote></li></ol><h3 id="游戏道具：足够大圆桌、足够多黑白围棋。游戏规则：黑白方回合制落子，直至桌面无法再放一颗棋子，则最后落子方胜。如何保证必赢？"><a href="#游戏道具：足够大圆桌、足够多黑白围棋。游戏规则：黑白方回合制落子，直至桌面无法再放一颗棋子，则最后落子方胜。如何保证必赢？" class="headerlink" title="游戏道具：足够大圆桌、足够多黑白围棋。游戏规则：黑白方回合制落子，直至桌面无法再放一颗棋子，则最后落子方胜。如何保证必赢？"></a>游戏道具：足够大圆桌、足够多黑白围棋。游戏规则：黑白方回合制落子，直至桌面无法再放一颗棋子，则最后落子方胜。如何保证必赢？</h3><blockquote><p>第一步占圆心，然后与对方镜像对称下棋，能保证必赢。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;2018年3月20日15时00分到酷家乐赴约Java实习现场面试，进行了接近2小时，记录如下：&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="笔经面经" scheme="http://zhangchong.xin/categories/%E7%AC%94%E7%BB%8F%E9%9D%A2%E7%BB%8F/"/>
    
    
      <category term="Java" scheme="http://zhangchong.xin/tags/Java/"/>
    
      <category term="酷家乐" scheme="http://zhangchong.xin/tags/%E9%85%B7%E5%AE%B6%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>51信用卡校招笔试</title>
    <link href="http://zhangchong.xin/2018/05/07/51%E4%BF%A1%E7%94%A8%E5%8D%A1%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AF%95/"/>
    <id>http://zhangchong.xin/2018/05/07/51信用卡校招笔试/</id>
    <published>2018-05-07T12:44:58.000Z</published>
    <updated>2019-03-10T06:19:06.464Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2018年5月7日19:00–21:00，参与了51信用卡春招在线考试，题型为20道单项选择题、10道不定项选择题、两道编程题、一道问答题。现将编程题记录如下：</p></blockquote><a id="more"></a><h1 id="51信用卡校招笔试"><a href="#51信用卡校招笔试" class="headerlink" title="51信用卡校招笔试"></a>51信用卡校招笔试</h1><h2 id="字符串AB"><a href="#字符串AB" class="headerlink" title="字符串AB"></a>字符串AB</h2><p><strong>题目描述</strong><br>&emsp;&emsp;有两个都是大写的字符串 A 和 B ，判断 A 中是否包含 B 中所有的字符。<br>&emsp;&emsp;注意：字符串 B 里的字符在 A 中不需要连续或有序。</p><p><strong>输入示例 1</strong><br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ABCU51NB;NB51</span><br></pre></td></tr></table></figure></div></p><p><strong>输出示例 1</strong><br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure></div></p><p><strong>输入示例 2</strong><br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ACGBEF;DB</span><br></pre></td></tr></table></figure></div></p><p><strong>输出示例 2</strong><br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure></div></p><blockquote><p>时间限制：C/C++语言 1 秒；其他语言 2 秒<br>空间限制：C/C++语言 32768 K；其他语言 65536 K</p></blockquote><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本题AC</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str = scanner.nextLine();</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> index = str.indexOf(<span class="string">";"</span>);</span><br><span class="line">        StringBuffer A = <span class="keyword">new</span> StringBuffer(str.substring(<span class="number">0</span>, index));</span><br><span class="line">        StringBuffer B = <span class="keyword">new</span> StringBuffer(str.substring(index + <span class="number">1</span>, str.length()));</span><br><span class="line">        <span class="keyword">if</span> (A.length() &lt; B.length()) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; B.length(); i++) &#123;</span><br><span class="line">            String substr = B.substring(i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> indexOfA = A.indexOf(substr);</span><br><span class="line">            <span class="keyword">if</span> (indexOfA &lt; <span class="number">0</span> || indexOfA &gt; A.length() - <span class="number">1</span>) &#123;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                A.deleteCharAt(indexOfA);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="红绿蓝"><a href="#红绿蓝" class="headerlink" title="红绿蓝"></a>红绿蓝</h2><p><strong>题目描述</strong><br>&emsp;&emsp;我们使用 R、G、B 分别表示红、绿、蓝三种颜色，给定一个包含这三个颜色的长度为 n 的数组，现在要求对数组进行分组，使相同颜色的相邻，并按照红、绿、蓝的顺序进行排序。<br>&emsp;&emsp;注意：排序需要在原数组中进行。</p><p><strong>输入示例 1</strong><br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RGRB</span><br></pre></td></tr></table></figure></div></p><p><strong>输出示例 1</strong><br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RRGB</span><br></pre></td></tr></table></figure></div></p><blockquote><p>时间限制：C/C++语言 1 秒；其他语言 2 秒<br>空间限制：C/C++语言 32768 K；其他语言 65536 K</p></blockquote><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本题AC</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str = scanner.nextLine();</span><br><span class="line">        StringBuffer color = <span class="keyword">new</span> StringBuffer(str);</span><br><span class="line">        <span class="keyword">int</span> loc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; color.length(); i++) &#123;</span><br><span class="line">            String substr = color.substring(i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (substr.equals(<span class="string">"R"</span>)) &#123;</span><br><span class="line">                String tempR = color.substring(loc, loc + <span class="number">1</span>);</span><br><span class="line">                color.replace(loc, loc + <span class="number">1</span>, <span class="string">"R"</span>);</span><br><span class="line">                color.replace(i, i + <span class="number">1</span>, tempR);</span><br><span class="line">                loc++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        loc = color.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = color.length() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            String substr = color.substring(j, j + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (substr.equals(<span class="string">"B"</span>)) &#123;</span><br><span class="line">                String tempB = color.substring(loc, loc + <span class="number">1</span>);</span><br><span class="line">                color.replace(loc, loc + <span class="number">1</span>, <span class="string">"B"</span>);</span><br><span class="line">                color.replace(j, j + <span class="number">1</span>, tempB);</span><br><span class="line">                loc--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;2018年5月7日19:00–21:00，参与了51信用卡春招在线考试，题型为20道单项选择题、10道不定项选择题、两道编程题、一道问答题。现将编程题记录如下：&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="笔经面经" scheme="http://zhangchong.xin/categories/%E7%AC%94%E7%BB%8F%E9%9D%A2%E7%BB%8F/"/>
    
    
      <category term="Java" scheme="http://zhangchong.xin/tags/Java/"/>
    
      <category term="51信用卡" scheme="http://zhangchong.xin/tags/51%E4%BF%A1%E7%94%A8%E5%8D%A1/"/>
    
      <category term="校招" scheme="http://zhangchong.xin/tags/%E6%A0%A1%E6%8B%9B/"/>
    
  </entry>
  
</feed>
